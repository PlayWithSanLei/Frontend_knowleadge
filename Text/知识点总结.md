# 前端面试常见知识点总结

## HTML



## CSS

### 1. display：none;  visibility:  hidden； opacity: 0 区别

1. + display: none 隐藏时，该元素不在文档流中占位置；

   + visibility: hidden 隐藏，只是视觉隐藏，还会在文档流中占位置;

   + opacity: 0 隐藏，也会在文档流中占位置，并且可以点击。

2. + display: none 会让元素完全从渲染树中消失，因此会引发回流和重绘；
   + visibility: hidden 不会让元素从渲染树中消失，因此不会引发回流，只会重绘；
   + opacity: 0 不会让元素从渲染树中消失，因此不会引发回流，只会重绘。

3. + display: none 和 opacity: 0是非继承属性，子孙节点消失是因为元素从渲染树中消失，因此修改子节点属性也无法显示；

   + visibility: hidden 是继承属性，子孙节点消失是因为继承了hidden，通过设置visibility: visible，可以让子节点显示。

     

### 2.  CSS 的 flex 布局

+ flex 弹性布局，有以下六个属性：
  + flex-direction;  flex-wrap;  flex-flow; justify-content; align-items;  align-content;

### 3.  rem 和 em 的区别



### 4.  实现一个div高度宽度由100变为110纯css实现（伪类+transition）

## JavaScript

### 1.  js为什么是单线程



### 2.  什么是面向对象



### 3.  undefined null  区别

+ undefined 表示一个变量未定义，不是人为的，部分用法如下：

  + 变量被声明了，但没有赋值时
  + 调用函数时，应该提供的参数没有提供
  + 对象没有赋值的属性
  + 函数没有返回值时

+ null 则表示一个变量被人为的设置为空对象，而不是原始状态，部分用法如下：

  + 作为对象原型链的终点。

  + 作为函数的参数，表示该函数的参数不是对象

    （ 需要传递参数，但是我们暂时不想传递，或者不需要传递，那么我们可以传一个空对象null）

### 4.  setTimeout（如何工作的，如果时间是0怎么办）    setInterval



### 5.  重绘 回流怎么触发

+ 触发（区别）
  + 触发回流：当渲染树的结构，布局，隐藏等发生改变时，就会引发回流（reflow），回流至少发生一次，因为在开始时要构建DOM树，会引发回流。引发回流时，受影响的那部分渲染树会失效，然后重新构建，完成回流后，浏览器会将修改的那部分重新绘制到页面上，称为重绘。
  + 触法重绘：当渲染树中的一部分属性发生修改，只影响外观，比如说背景颜色之类的，不影响布局，就会引发重绘。
+ 注意
  + 回流一定重绘，重绘不一定回流
+ 如何减少
  + 比如要修改同一元素样式的时候，不用一个一个修改，直接创建一个类，这样只引发一次回流；
  + 如果要修改一个DOM元素多条样式时，也可以先隐藏，修改完毕后再显示；
  + ......

### 6.  箭头函数和普通函数区别

+ 箭头函数相当于一个匿名函数，只有一个参数的时候，小括号可以省略，只有一个表达式的时候，大括号可以省略；
+ 箭头函数不能函数提升，也就是说不能先调用，再声明；
+ 箭头函数不能用作构造函数，不能使用new方法；
+ 普通函数this谁调用指向谁，箭头函数指向上下文对象；
+ 箭头函数不能使用arguments，super等方法，不能使用prototype原型对象。

### 7.  数组遍历方法实现reduce



### 8.  同步任务 异步任务



### 9.  事件循环

#### 9.1 JavaScript是单线程的，非阻塞的

单线程：

> JavaScript的主要用途是与用户互动，以及操作DOM。如果它是多线程的话，会有很多复杂的问题要处理，比如有两个线程要同时操作DOM，一个线程删除了当前的DOM节点，一个线程要是操作当前的DOM节点，最后应该以哪个线程的操作为准？为了避免这种情况发生，所以JS是单线程的。即使HTML5提出了WebWorker标准，它还是有很多限制，受主线程控制，是主线程的子线程。

非阻塞：

> 通过EventLoop实现

#### 9.2 浏览器的事件循环

##### 执行栈和事件队列

为了更好的理解Event Loop，请看下图（转引自Philip Roberts的演讲[《Help, I'm stuck in an event-loop》](https://link.segmentfault.com/?url=https%3A%2F%2Fvimeo.com%2F96425312)）

<img src="https://segmentfault.com/img/remote/1460000022805527" alt="Help, I'm stuck in an event-loop" style="zoom: 67%;" />

**执行栈**：同步代码的执行，按照顺序添加到执行栈中

```javascript
function a() {
  b();
  console.log('a');
}
function b() {
  console.log('b');
}
a();
```

我们可以通过使用 [Loupe](https://link.segmentfault.com/?url=http%3A%2F%2Flatentflip.com%2Floupe)(Loupe是一种可视化工具，可以帮助您了解JavaScript的调用堆栈/事件循环/回调队列如何相互影响)工具来了解上面代码的执行情况。

> + 执行函数a()先入栈
> + a()中先执行函数b()，函数b()入栈
> + 执行函数b()，console.log('b')入栈
> + 输出b，执行完成，出栈
> + console.log('a')入栈，执行，输出a，出栈
> + 函数a执行完成，出栈。

**事件队列**：异步代码的执行，**遇到异步事件不会等待它返回结果，而是将这个事件挂起**，继续执行**执行栈中的其他任务**。当异步事件返回结果，将它放到事件队列中，**被放入事件队列不会立即执行起回调，而是等待当前执行栈中所有任务都执行完毕**，主线程空闲状态，主线程会去查找事件队列中是否有任务，如果有，**则取出排在第一位的事件**，并把这个事件对应的回调放到执行栈中，然后执行其中的同步代码。

在上面的基础上添加异步事件

```javascript
function a() {
  b();
  console.log('a')
}

function b() {
  console.log('b')
  setTimeout(function () {
    console.log('c')
  },2000)
}

a()
```

下图做总结：

<img src="https://segmentfault.com/img/remote/1460000022805532" alt="执行栈和事件队列" style="zoom:67%;" />

**宏任务和微任务**

为什么要引入微任务，只有一种类型的任务不行吗？

页面渲染事件，各种IO的完成事件等随时被添加到任务队列中，一直会保持先进先出的原则执行，我们不能准确地控制这些事件被添加到任务队列中的位置。但是这个时候突然有高优先级的任务需要尽快执行，那么一种类型的任务就不合适了，所以引入了微任务队列。

不同的异步任务被分为：宏任务和微任务。

**宏任务**：

> + script(整体代码)
> + setTimeout()
> + setInterval()
> + postMessage
> + I/O
> + UI交互事件

微任务：

> + new Promise().then(回调)
> + MutationObserver(HTML5新特性)

**运行机制**

异步任务的返回结果会被放到一个任务队列中，根据异步事件的类型，这个事件实际上会被放到对应的宏任务和微任务队列中去。

在当前执行栈为空时，主线程会查看微任务队列是否有事件存在

+ 存在：依次执行队列中的事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的事件，把当前的回调加到当前执行栈
+ 不存在：再去宏任务队列中取出一个事件并把对应的事件加入当前执行栈

当前执行栈执行完毕后会立刻处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件，同一次事件循环中，微任务永远在宏任务之前执行。

在事件循环中，每进行一次循环操作成为tick，每一次tick的任务处理模型时比较复杂的，但是关键步骤如下：

> + 执行一个宏任务（栈中没有就从事件队列中获取）
> + 执行过程中如果遇到微任务，就把它添加到微任务的任务队列中
> + 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
> + 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
> + 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）

简单总结一下执行的顺序：

执行宏任务，然后执行宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，再回到宏任务中进行下一轮循环。

![宏任务和微任务](https://segmentfault.com/img/remote/1460000022805533)

```javascript
console.log('start')

setTimeout(() => {
    console.log('setTimeout')
}, 0)

Promise.resolve().then(() => {
    console.log('promise1')
}).then(() => {
    console.log('promise2')
})
console.log('end')
```

> 1. 全局代码压入执行栈行，输出start
> 2. setTimeout压入macrotask队列，promise.then回调放入microtask队列，最后执行console.log('end')，输出end
> 3. 调用栈中的代码执行完成（全局代码属于宏任务），接下来开始执行微任务队列中的代码，执行promise回调，输出promise1，promise回调函数默认返回undefined,promise状态变为fulfilled，触发接下来的then回调，继续压入microtask队列，此时产生了新的微任务，会接着把当前的微任务队列执行完，此时执行第二个promise.then回调，输出promise2
> 4. 此时，microtask队列已清空，接下来会执行UI渲染工作（如果有的话），然后开始下一轮事件循环，执行setTimeout的回调，输出setTimeout

#### 9.3 node环境下的事件循环

**和浏览器环境的不同**

表现出的状态和浏览器大致相同，不同的是node中有一套自己的模型。node中事件循环的实现依赖libuv引擎。Node的事件循环存在几个阶段。

如果是node10及其之前版本，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列中的任务。

node版本更新到11以后，eventloop运行原理发生了变化，一旦执行一个阶段里的宏任务（setTimeout,setInterval和setImmediate）就立刻执行微任务队列，跟浏览器趋于一致。下面例子中的代码是按最新的去进行分析的。

**事件循环模型**

```markdown
┌───────────────────────┐
┌─>│        timers         │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     I/O callbacks     │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle, prepare     │
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │   incoming:   │
│  │         poll          │<──connections───     │
│  └──────────┬────────────┘      │   data, etc.  │
│  ┌──────────┴────────────┐      └───────────────┘
│  │        check          │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks    │
   └───────────────────────┘
```

**事件循环各阶段讲解**

node中事件循环的顺序

外部输入数据-->轮询阶段(poll)-->检查阶段(check)-->关闭事件回调阶段(close callback)-->定时器检查阶段(timer)-->I/O事件回调阶段(I/O callbacks)-->闲置阶段(idle,prepare)-->轮询阶段......

这些阶段大致的功能如下：

+ 定时器检测阶段（timers）：这个阶段执行定时器队列中的回调如setTimeout()和setInterval().
+ I/O事件回调阶段（I/O callbacks）：这个阶段执行几乎所有的回调，但是不包括close事件，定时器和setImmediate()的回调。
+ 闲置阶段（idle,prepare）：这个阶段仅在内部使用，可以不必理会。
+ 轮询阶段（poll）：等待新的I/O事件，node在一些特殊情况下会阻塞在这里。
+ 检查阶段（check）：setImmediate()的回调会在这个阶段执行。
+ 关闭事件回调阶段（close callbacks）：例如socket.on('close')这种close事件的回调

poll：
这个阶段是轮询时间，用于等待还未返回的 I/O 事件，比如服务器的回应、用户移动鼠标等等。
这个阶段的时间会比较长。如果没有其他异步任务要处理（比如到期的定时器），会一直停留在这个阶段，等待 I/O 请求返回结果。
check:
该阶段执行setImmediate()的回调函数。

close:
该阶段执行关闭请求的回调函数，比如socket.on('close', ...)。

timer阶段:
这个是定时器阶段，处理setTimeout()和setInterval()的回调函数。进入这个阶段后，主线程会检查一下当前时间，是否满足定时器的条件。如果满足就执行回调函数，否则就离开这个阶段。

I/O callback阶段：
除了以下的回调函数，其他都在这个阶段执行：

- setTimeout()和setInterval()的回调函数
- setImmediate()的回调函数
- 用于关闭请求的回调函数，比如socket.on('close', ...)

**宏任务和微任务**

宏任务：

> + setImmediate
> + setTimeout
> + setInterval
> +  script（整体代码)
> +  I/O 操作等。

微任务：

> + process.nextTick
> + new Promise().then(回调)

#### 9.4 经典题目分析

（待补充）

### 10.  基本数据类型 引用数据类型 及区别

+ 基本数据类型：数字型，字符串型，null，undefinned，布尔型
+ 引用数据类型：对象（数组，正则，函数）
+ 区别：基本数据类型实际数据放在栈中，而引用数据类型的实际数据放在堆内存中

（栈：自动分配内存空间，由系统自动释放； 堆：动态分配内存空间，大小也不一定会释放）

### 11.   微任务



### 12.  js数组扁平法



### 13. set的各种方法

​	

### 14. map的各种方法



### 15. set map 的区别



###  







## Vue（ + http)

### 1.  Vue 2.0 Vue 3.0 区别



### 2.  Vue生命周期



### 3.  watch computed methods区别



### 4.  v-if v-for 以及v-if v-show区别



### 5.  Vue父子组件之间如何传值



### 6.  讲讲单页面应用和多页面应用



### 7.   Vue数据流



### 8. Vue双向数据绑定



### 9.  webpack是什么



### 10. 怎么提高打包速度，减少打包体积



### 11.  Vue 技术栈



### 12.  说说 promise 的 async  await



### 13.  promise有哪些方法，all  race 方法以及应用场景



### 14.  cookie 和 webstorage区别

+ 特性
  + cookie 由服务器生成，存储在浏览器的，可以设置失效时间
  + localstorage 除非主动删除，否则即使浏览器关闭内容也不会清除
  + sessionstorage 浏览器关闭后数据会自动删除
+ 大小
  + cookie 可以存储大小约为4KB 
  + webstorage 可以存储大小为5MB左右
+ 与服务器
  + cookie 由服务器生成，发送给服务器，会在服务器下一次请求时被携带
  + webstorage 与服务器没有联系
+ 接口
  + cookie 接口原生的不友好，需要程序员自己封装
  + webstorage 原生接口就可以

### 15.  cookie怎么保存到本地的，cookie怎么实现跨域



### 16.  跨域相关问题



### 17.  常见状态码

+ 200： OK
+ 301：永久重定向
+ 302：临时重定向
+ 303：临时重定向，可以使用get获取到新的URL
+ 304：上次请求的网页未修改（可以进行强制刷新）
+ 401：未授权
+ 403：禁止访问
+ 404：找不到资源

### 18.  v-for 中 key 的作用，没有 key 会怎么样

+ 在写v-for的时候必须要加key，作为唯一标识，可以提高渲染性能，防止数据混乱。







## 其他

### 1.  职业规划（3-5年）























