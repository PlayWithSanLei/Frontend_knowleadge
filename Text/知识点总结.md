# 前端面试常见知识点总结

## HTML

### 1.1  H5新增的东西

+ 绘画canvas
+ 用于媒介回放的video和audio元素
+ localstorage，sessionstorage
+ 语义化更好的内容元素：article，footer，header，nav，section
+ 表单控件：calendar，date，time，email，url，search
+ 新的技术：webwoker，websocket，geolocation

### 1.2 H5废除的东西

+ 一些纯表现的元素：basefont，big，center，font，等
+ 对可用性产生负面影响的元素：frame，frameset，noframes

### 2.  HTML最新哪个版本，之前哪个版本

+ HTML5之前的版本是 HTML 4.01 ，HTML5版本为当前最新的HTML版本。
+ HTML4.01、HTML5 之间的区别： **声明区别**
  + HTML5 ：<!DOCTYPE html>
  + HTML4.01：规定了三种文档类型：Strict, Transitional, 以及Frameset. 中译为：严格版本，过渡版本，以及基于框架的版本。

### 3.  语义化怎么理解（为什么语义化）

+ 我们可以将HTML的语义化总结为： **用最恰当的标签来标记内容。**
+ **如何理解**：比如需要加入一个标题，这个标题的字体比正文的要大写，还要加粗。能够实现这种效果的方法有很多，比如用CSS样式进行渲染。这样的效果看起来像是一个标题，但是他对浏览器来说，只是一个被渲染过的文本，无法知道他是一个标题。若要让浏览器知道他是一个标题，应该用hx标签来进行标记。
+ 好处：
  + 去掉或者丢失样式的时候能够让页面呈现出清晰的结构；
  + 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓 取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；
  + 方便其他设备解析（如屏幕阅读器、盲 人阅读器、移动设备）以意义的方式来渲染网页；
  + 便于团队开发和维护，语义化更具可读性，是下一步吧网页的 重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。

### 4. HTML块级元素和 行内元素有哪些？ 区别？ 怎么互相转变

+ 块级元素
  + 每个块级元素通常都会独占一行或者是多行，可以对其单独设置高度,宽度以及对齐等属性。
  + 常见的块级元素有：<h1>~<h6>,<p>,<div>,<ul>,<ol>,<li>	等
  + 块级元素的特点：
    + 块级元素会独占一行
    + 高度，行高，外边距和内边距都可以单独设置
    + 宽度默认是容器的100%
    + 可以容纳内联元素和其他的块级元素
+ 行内元素
  + 不占有独立的区域，仅仅依靠自己的字体大小或者是图像大小来支撑结构。一般不可以设置宽度，高度以及对齐等属性。
  + 常见的行内元素有：<a>,<strong>,<b>,<em>,<del>,<span>等
  + 行内元素的特点：
    + 和相邻的行内元素在一行上
    + 高度和宽度无效，但是水平方向上的padding和margin可以设置，垂直方向上的无效
    + 默认的宽度就是它本身的宽度
    + 行内元素只能容纳纯文本或者是其他的行内元素（a标签除外）
+ 注意：
  + 只有文字才能组成段落，因此类似<p>,<h1>~<h6>,<dt>等里面不能放块级元素；因为它们都是文字块级标签，里面不能再存放其他的块级标签。
  + 链接里面不能再存放链接
+ 行内块级元素
  + 在行内元素中有几个特殊的标签，<img/>,<input/>,<td/>,可以设置它们的宽高度以及对齐属性
  + 行内块级元素的特点：
    + 和相邻的行内元素（行内块）在一行上，但是中间会有空白的间隙
    + 默认的宽度就是本身内容的宽度
    + 高度，行高，内边距和外边距都可以设置
+ 显示模式的转换
  + 块转行内：display-inline；
  + 行内转块：display：block；
  + 块，行内元素转换为行内块：display：inline-block

### 5. 列表

​	**HTML 支持有序、无序和定义列表**

+ 有序列表

  ` <ol> <li> </li> </ol>`

+ 无序列表

  ` <ul> <li> </li> </ul>`

+ 定义列表(  自定义列表不仅仅是一列项目，而是项目及其注释的组合。)

  ` <dl> ` 

  ​	`	<dt> `

  ​		`<dd></dd>`

  ​		`<dd></dd>`

  ​	` </dt> ` 

  `</dl>`

## CSS

### 1. display：none;  visibility:  hidden； opacity: 0 区别

1. + display: none 隐藏时，该元素不在文档流中占位置；

   + visibility: hidden 隐藏，只是视觉隐藏，还会在文档流中占位置;

   + opacity: 0 隐藏，也会在文档流中占位置，并且可以点击。

2. + display: none 会让元素完全从渲染树中消失，因此会引发回流和重绘；
   + visibility: hidden 不会让元素从渲染树中消失，因此不会引发回流，只会重绘；
   + opacity: 0 不会让元素从渲染树中消失，因此不会引发回流，只会重绘。

3. + display: none 和 opacity: 0是非继承属性，子孙节点消失是因为元素从渲染树中消失，因此修改子节点属性也无法显示；

   + visibility: hidden 是继承属性，子孙节点消失是因为继承了hidden，通过设置visibility: visible，可以让子节点显示。


### 2.  CSS 的 flex 布局

flex 弹性布局，有以下六个属性：

+ flex-direction;  
+ flex-wrap;  
+ flex-flow; 
+ justify-content; 
+ align-items;  
+ align-content;

1. 水平（主轴上）对齐方式：

   justify-content：flex-start | flex-end | center | space-between | space-around

2. 十字交叉轴上对齐方式

   align-items：flex-start | flex-end | center | baseline | stretch;

3. 项目排列方向

   flex-direction：row | row-reverse | column | column-reverse;

4. 换行方式

   flex-wrap：nowrap（不换行） | wrap（向下换） | wrap-reverse（向上换）;

5. flex-flow

   flex-direction和flex-wrap的简写

6. 多根轴线的对齐方式

    align-content：flex-start | flex-end | center | space-between | space-around | stretch;

子项目属性：

+ order:         
  + 定义项目的排列顺序。数值越小，排列越靠前，默认为0。
+ flex-grow:  
  +  定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。  
  +  如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。                 
  +  如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 
+ flex-shrink: 
  + 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
  + 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。                 
  + 如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。
+ flex-basis:  
  + 定义了在分配多余空间之前，项目占据的主轴空间（main size）
+ flex:           
  + 属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。                 
  + 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 
+ align-self:  
  +  属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。                 
  +  默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。

### 3.  rem  em  px 的区别

+ em 是一个相对长度单位，相对于自身元素的字体大小，如果没有设置，就是相对于父类或者是文档字体大小；
+ rem 也是一个相对长度单位，相对于html的字体大小，一般用于移动端UI适配；
+ px 像素，也是一个相对长度单位，相对于显示器的分辨率

### 4.  line-hight作用（height，line-height，font-size）

+ lin-height 是行高，是上下两行基线之间的距离
+ font-size 是顶线和底线之间的距离

![在这里插入图片描述](https://img-blog.csdn.net/20180920105701124?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EyMDEzMTI2Mzcw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

+ height 与 line-height
  + height = line-height时，居中
  + height > line-height时，靠上
  + height < line-height时，靠下
+ line-height 作用：行高，设置文本垂直居中

### 5.  CSS3新特性

#### 	5.1 过渡

​	**语法**

```scss
transition： CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认0)
```

​	例1

```css
/*宽度从原始值到制定值的一个过渡，运动曲线ease,运动时间0.5秒，0.2秒后执行过渡*/
transition：width,.5s,ease,.2s
```

​	例2

```awk
/*所有属性从原始值到制定值的一个过渡，运动曲线ease,运动时间0.5秒*/
transition：all,.5s
```

​	上面例子是简写模式，也可以分开写各个属性（这个在下面就不再重复了）

```css
transition-property: width;
transition-duration: 1s;
transition-timing-function: linear;
transition-delay: 2s;
```

​	可以实现 hover效果，下拉菜单等效果，用了过渡之后不会很生硬，有一个变化的过程，显得比较生动。

#### 	5.2 动画

​	**语法**

```apache
animation：动画名称，一个周期花费时间，运动曲线（默认ease），动画延迟（默认0），播放次数（默认1），是否反向播放动画（默认normal），是否暂停动画（默认running）
@keyframes 动画名称 {
    0%{
        transform:rotate(180deg);
        opacity: 0;
    }
    100%{
        transform:rotate(0deg);
        opacity: 1;
    }
}
```

​	例1

```css
/*执行一次logo2-line动画，运动时间2秒，运动曲线为 linear*/
animation: logo2-line 2s linear;
```

​	例2

```css
/*2秒后开始执行一次logo2-line动画，运动时间2秒，运动曲线为 linear*/
animation: logo2-line 2s linear 2s;
```

​	例3

```css
/*无限执行logo2-line动画，每次运动时间2秒，运动曲线为 linear，并且执行反向动画*/
animation: logo2-line 2s linear alternate infinite;
```

​	还有一个重要属性

```coq
animation-fill-mode : none | forwards | backwards | both;
/*none：不改变默认行为。    
forwards ：当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）。    
backwards：在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）。 
both：向前和向后填充模式都被应用。  */      
```

#### 	5.3 转换

​	**语法**

​	transform:适用于2D或3D转换的元素
​	transform-origin：转换元素的位置（围绕那个点进行转换）。默认(x,y,z)：(50%,50%,0)

​	**属性**

​	transform:rotate(30deg);

​	transform:translate(30px,30px);

​	transform:scale(.8);

​	transform: skew(10deg,10deg);

​	transform:rotateX(180deg);

​	transform:rotateY(180deg);

​	transform:rotate3d(10,10,10,90deg);

​	**补充---skew倾斜**

​	语法：

```
transform: skewX(x);        /*沿X轴方向倾斜*/
transform: skewY(y);        /*沿Y轴方向倾斜*/
transform: skew(x, y);       /*沿X轴和Y轴同时倾斜*/
```

​	说明：

跟translate()、scale()方法类似，倾斜也有3种情况：skewX()、skewY()、skew()。

参数x表示元素在x轴方向的倾斜度数，单位为deg（即degree的缩写）。如果度数为正，则表示元素沿x轴方向逆时针倾斜；如果度数为负，则表示元素沿x轴方向顺时针倾斜。

参数y表示元素在y轴方向的倾斜度数，单位为deg。如果度数为正，则表示元素沿y轴方向顺时针倾斜；如果度数为负，则表示元素沿y轴方向逆时针倾斜。

#### 	5.4 选择器（属性选择器，结构伪类选择器）

![preview](https://segmentfault.com/img/bVTd2d?w=780&h=728/view)



### 6.  



### 7. div table 布局

**背景介绍**

​	table布局是网页早期布局实现的主要手段，当时的网页构成，相对也比较简单，多是以文本以及静态图片等组成的，类似于报纸的形式，分区分块显示，table标签的结构表现恰好可以满足这样的要求。但是随着网页要求的提高和技术的不断探索更迭，尤其是W3C（万维网联盟）及其他标准组织制定的标准出台后，明确了table标签不是布局工具，使table标签重新回到其原有的作用上（即仅作为呈现表格化数据的作用），而提倡使用div+css的布局组合。

**使用div的优点**

+ div 布局改版的时候更方便，只要改css文件
+ div 布局页面加载速度更快，结构化清晰，页面显示整洁
+ div 布局表现与结构分离
+ div 布局易于优化（seo），排名更容易靠前

### 8.  用过什么布局（圣杯，双飞翼？两栏，三栏？）



### 9.



### 10.  



### 11. 盒子模型

+ 盒子模型由四部分组成：内容区（content）、填充(padding)、边框(border)和外边距(margin)
+ 内容区（content）
  + 内容区有三个属性，width、height 和overflow。
  + 使用width和height属性可以指定盒子内容区的高度和宽度，
  + 当内容信息太多，超出内容区所占范围时，可以使用overflow 溢出属性来指定处理方法。
    + 当overflow 属性值为hidden时，溢出部分将不可见；
    + 为visible时，溢出的内容信息可见，只是被呈现在盒子的外部；
    + 当为scroll时，滚动条将被自动添加到盒子中，用户可以通过拉动滚动条显示内容信息；
    + 当为auto时，将由浏览器决定如何处理溢出部分。
+ 填充（padding）
  + 填充是内容区和[边框](https://baike.baidu.com/item/边框/7166650)之间的空间。
  + 填充的属性有五种 ，即padding -top、padding -bottom、padding -left、padding-right 以及综合了以上四种方向的快捷填充属性padding。
+ 边框（border）
  + [边框](https://baike.baidu.com/item/边框/7166650)是环绕内容区和填充的边界。
  + 边框的属性有border-style、border-width和border-color 以及综合了以上三类属性的快捷边框属性 border。
  + border-style 属性是边框最重要的属性，如果没有指定边框样式，其他的边框属性都会被忽略，边框将不存在。CSS规定了dotted（点线）、dashed（虚线）、solid(实线)等九种边框样式。
  + 使用border-width属性可以指定边框的宽度，其属性值可以是长度计量值，也可以是CSS规定的thin、medium 和thick。
  + 使用border-color属性可以为边框指定相应的颜色，其属性值可以是[RGB](https://baike.baidu.com/item/RGB/342517)值，也可以是CSS 规定的17个颜色名 。
  + 在设定以上三种边框属性时，既可以进行边框四个方向整体的快捷设置，也可以进行四个方向的专向设置，如border: 2px solid green 或border-top-style: solid、border-left-color: red等。
  + 设置盒子背景色属性时，在IE中背景不会延伸到边框区域，但在FF等标准浏览器中，背景颜色可以延伸到边框区域，特别是单边框设置为点线或虚线时能看到效果 。
+ 空白边（margin）
  + 空白边位于盒子的最外围，是添加在边框外周围的空间。
  + 空白边的属性有五种 ，即margin-top、margin-bottom、margin- left、margin-right以及综合了以上四种方向的快捷空白边属性margin，其具体的设置和使用与填充属性类似。
+ 盒子模型分为两类：W3C盒模型（标准盒模型），IE盒模型（怪异盒模型）
+ W3C盒模型（标准盒模型）
  + box-sizing : content-box（默认）
  + 设置的宽度是内容的宽度，整个盒子模型总体的宽度 = 设置的宽度 + 左右内边距 + 左右边框 + 左右外边距
+ IE盒模型（怪异盒模型）
  + box-sizing： border-box
  + 设置的宽度是除外边距外的所有宽度，整个盒子模型总体的宽度 = 设置的宽度 + 左右外边距

### 12. position

+ **关于CSS position，来自MDN的描述：**

> CSS position属性用于指定一个元素在文档中的定位方式。top、right、bottom、left 属性则决定了该元素的最终位置。

​	然后来看看什么是文档流(normal flow)，下面是 [www.w3.org](https://www.w3.org/TR/CSS21/visuren.html#) 的描述：

> **Normal flow**
>
> Boxes in the normal flow belong to a formatting context, which may be block or inline, but not both simultaneously. [Block-level](https://www.w3.org/TR/CSS21/visuren.html#block-level) boxes participate in a [block formatting](https://www.w3.org/TR/CSS21/visuren.html#block-formatting) context. [Inline-level boxes](https://www.w3.org/TR/CSS21/visuren.html#inline-level) participate in an [inline formatting](https://www.w3.org/TR/CSS21/visuren.html#inline-formatting) context.

​		个人补充（此处参考[FungLeo](https://blog.csdn.net/fungleo)的博客文章，[原文点此](https://blog.csdn.net/fungleo/article/details/50056111)）：

1. normal flow直译为常规流、正常流，国内不知何原因大多译为文档流；
2. 窗体自上而下分成一行一行，并在每行中按从左至右的顺序排放元素；
3. 每个非浮动块级元素都独占一行， 浮动元素则按规定浮在行的一端，若当前行容不下，则另起新行再浮动；
4. 内联元素也不会独占一行，几乎所有元素(包括块级，内联和列表元素）均可生成子行，用于摆放子元素；
5. 有三种情况将使得元素脱离normal flow而存在，分别是 float，absolute ，fixed，但是在IE6中浮动元素也存在于normal flow中。

+ **一、position: static**

MDN的描述：

> 该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top、right、bottom、left 属性无效。

个人补充：static是position的默认值。



```html
 1 <!DOCTYPE html>
 2 <html lang="en">
 3 <head>
 4     <meta charset="UTF-8">
 5     <title>CSS-position-static</title>
 6     <link rel="stylesheet" href="https://cdn.bootcss.com/normalize/8.0.0/normalize.css">
 7     <style>
 8         .container{
 9             background-color: #868686;
10             width: 100%;
11             height: 300px;
12         }
13         .content{
14             background-color: yellow;
15             width: 100px;
16             height: 100px;
17             position: static;
18             left: 10px;/* 这个left没有起作用 */
19         }
20     </style>
21 </head>
22 <body>
23     <div class="container">
24         <div class="content">    
25         </div>
26     </div>
27 </body>
28 </html>
```



![img](https://files.cnblogs.com/files/guolao/static.bmp)

对 content 的 position 设定 static 后，left就失效了，而元素（content）就以正常的 normal flow 形式呈现。

+ **二、position: relative**

MDN的描述：

> 该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。position:relative 对 table-*-group, table-row, table-column, table-cell, table-caption 元素无效。

个人理解：相对于normal flow中的原位置来定位。

![img](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif) position: relative

![img](https://files.cnblogs.com/files/guolao/relative_0.bmp)

这是没有设置left、top等属性时，正常出现在normal flow中的位置。

接着添加left、top：



```css
1 .content_1{
2                 background-color: red;
3                 width: 100px;
4                 height: 100px;
5                 position: relative;/* 这里使用了relative  */
6                 left: 20px;/* 这里设置了left和top */
7                 top: 20px;            
8             }
```



![img](https://files.cnblogs.com/files/guolao/relative_1.bmp)

可以看到，元素（content_1）的位置相对于其原位置（normal flow中的正常位置）进行了移动。

+ **三、position: absolute**

MDN的描述

> 不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margin），且不会与其他边距合并。

个人理解：生成绝对定位的元素，其相对于 static 定位以外的第一个父元素进行定位,会脱离normal flow。**注意：是除了static外**

![img](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif) position: absolute

![img](https://files.cnblogs.com/files/guolao/absolute.bmp)

因为 content 的父元素 container 没有设置 position，默认为 static，所以找到的第一个父元素是 body（<body></body>），可以看成是元素（content）相对于 body 向下移动10px。

+ **四、position: fixed**

MDN的描述

> 不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed属性会创建新的层叠上下文。当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。

个人理解：fixed相对于window固定，滚动浏览器窗口并不会使其移动，会脱离normal flow。

![img](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif) position: fixed

这里就不上图了，看一下代码或者自己动手码一下就能理解。

+ **五、position: sticky**

  MDN的描述

> 盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 table`时`），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。position: sticky对 table元素的效果与 position: relative 相同。

因为各大浏览器对于sticky的兼容问题，而且JS也可以实现这个功能，在这里就不进行深入了，了解一下就好。

+ 六、**position: inherit**

  [w3school.com](http://www.w3school.com.cn/cssref/pr_class_position.asp)的 描述

  规定应该从父元素继承 position 属性的值。

  inherit 继承父元素，这个用得不多，所以也不继续深入了。

### 13.  伪类、伪元素

+ css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说：伪类和伪元素是用来修饰不在文档树中的部分。

+ 伪类

  伪类用于定义元素的特殊状态。

  ![img](https://img-blog.csdnimg.cn/20190527175840224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3Njc0NDM5,size_16,color_FFFFFF,t_70)

+ 伪元素（双冒号）

  CSS 伪元素用于设置元素指定部分的样式。

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/2019052717580919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3Njc0NDM5,size_16,color_FFFFFF,t_70)

+ 二者区别

  + 伪类与伪元素的区别在于：有没有创建一个文档树之外的元素。
    + 伪元素：不存在在DOM文档中，是虚拟的元素，是创建新元素。 这个新元素(伪元素) 是某个元素的子元素，这个子元素虽然在逻辑上存在，但却并不实际存在于文档树中。所以不能通过js操作。
    + 伪类：存在DOM文档中，(无标签,找不到, 只有符合触发条件时才能看到 ), 逻辑上存在但在文档树中却无须标识的“幽灵”分类。
  + 可以同时使用多个伪类，而只能同时使用一个伪元素。
  + 伪类是  : ，伪元素是  : : 。（伪元素：也可以，：是CSS2的，兼容性更好）
  + 注意伪元素要加content。

### 14.  选择器优先级

+ 基础选择器优先级

  ！important  >  行内样式（1000）  >  id选择器（100）  >  类选择器（10）  >   元素选择器（1）  >  通配符选择器（0）>  继承（没有优先级）

+ 伪类选择器、属性选择器 == 10

+ 关系选择器、伪元素选择器 == 1

+ 当有多种选择器时，需要将多种选择器的优先级相加然后进行比较，相等则使用靠后的样式

### 15.  怎么设置0.5px边框（0）



### 16.  sass，less 区别（0）



## JavaScript

### 1.  js为什么是单线程

+ 这是基于js 的用途。js 是浏览器的脚本语言，用于实现用户与浏览器的交互，这就决定了他只能是单线程；
+ 如果是多线程，有两个进程要操作同一个DOM元素，一个删除，一个修改，就会产生矛盾，因此设置为单线程更合适；

### 2.  什么是面向对象

+ 对象是什么。简言之，包含属性和方法的就是对象。属性是静态的，通常写在构造函数中，方法是动态的，公用的，通常写在原型中。
+ 对象是类的实例和具体，类是对象的集合。
+ 基本特征有封装，继承，多态
  + 封装：把相关的信息（无论数据或方法）存储在对象中的能力。（用户在使用的时候不用考虑函数内部代码是如何运行的，只需要会用这个功能就可）
  + 继承：子类可以继承父类的属性和方法，子类自己也有属性和方法
  + 多态： 编写能以多种方法运行的函数或方法的能力

### 3.  undefined null  区别

+ undefined 表示一个变量未定义，不是人为的，部分用法如下：

  + 变量被声明了，但没有赋值时
  + 调用函数时，应该提供的参数没有提供
  + 对象没有赋值的属性
  + 函数没有返回值时

+ null 则表示一个变量被人为的设置为空对象，而不是原始状态，部分用法如下：

  + 作为对象原型链的终点。

  + 作为函数的参数，表示该函数的参数不是对象

    （ 需要传递参数，但是我们暂时不想传递，或者不需要传递，那么我们可以传一个空对象null）

### 4.  setTimeout（如何工作的，如果时间是0怎么办）    setInterval

+ settimeout 是异步任务，在碰到时，会被放入event table 中，等到了时间再推入事件队列中，当主线程执行完毕，空闲时，会执行事件队列中的settimeout
+ setinterval 也是异步任务，时间到了就推入事件队列，，再过这么长时间再推入，一直推。

### 5.  重绘 回流怎么触发

+ 触发（区别）
  + 触发回流：当渲染树的结构，布局，隐藏等发生改变时，就会引发回流（reflow），回流至少发生一次，因为在开始时要构建DOM树，会引发回流。引发回流时，受影响的那部分渲染树会失效，然后重新构建，完成回流后，浏览器会将修改的那部分重新绘制到页面上，称为重绘。
  + 触法重绘：当渲染树中的一部分属性发生修改，只影响外观，比如说背景颜色之类的，不影响布局，就会引发重绘。
+ 注意
  + 回流一定重绘，重绘不一定回流
+ 如何减少
  + 比如要修改同一元素样式的时候，不用一个一个修改，直接创建一个类，这样只引发一次回流；
  + 如果要修改一个DOM元素多条样式时，也可以先隐藏，修改完毕后再显示；
  + ......

### 6.  箭头函数和普通函数区别

+ 箭头函数相当于一个匿名函数，只有一个参数的时候，小括号可以省略，只有一个表达式的时候，大括号可以省略；
+ 箭头函数不能函数提升，也就是说不能先调用，再声明；
+ 箭头函数不能用作构造函数，不能使用new方法；
+ 普通函数this谁调用指向谁，箭头函数指向上下文对象；
+ 箭头函数不能使用arguments，super等方法，不能使用prototype原型对象。

### 7.  数组遍历方法实现reduce（0）



### 8.  同步任务 异步任务

+ 同步任务会进入主线程执行，不会挂载
+ 异步任务不会进入主线程，会进入event table ，达到对应条件就推入事件队列中，主线程空闲，执行事件队列中的任务

### 9.  事件循环

#### 9.1 JavaScript是单线程的，非阻塞的

单线程：

> JavaScript的主要用途是与用户互动，以及操作DOM。如果它是多线程的话，会有很多复杂的问题要处理，比如有两个线程要同时操作DOM，一个线程删除了当前的DOM节点，一个线程要是操作当前的DOM节点，最后应该以哪个线程的操作为准？为了避免这种情况发生，所以JS是单线程的。即使HTML5提出了WebWorker标准，它还是有很多限制，受主线程控制，是主线程的子线程。

非阻塞：

> 通过EventLoop实现

#### 9.2 浏览器的事件循环

##### 执行栈和事件队列

为了更好的理解Event Loop，请看下图（转引自Philip Roberts的演讲[《Help, I'm stuck in an event-loop》](https://link.segmentfault.com/?url=https%3A%2F%2Fvimeo.com%2F96425312)）

<img src="https://segmentfault.com/img/remote/1460000022805527" alt="Help, I'm stuck in an event-loop" style="zoom: 67%;" />

**执行栈**：同步代码的执行，按照顺序添加到执行栈中

```javascript
function a() {
  b();
  console.log('a');
}
function b() {
  console.log('b');
}
a();
```

我们可以通过使用 [Loupe](https://link.segmentfault.com/?url=http%3A%2F%2Flatentflip.com%2Floupe)(Loupe是一种可视化工具，可以帮助您了解JavaScript的调用堆栈/事件循环/回调队列如何相互影响)工具来了解上面代码的执行情况。

> + 执行函数a()先入栈
> + a()中先执行函数b()，函数b()入栈
> + 执行函数b()，console.log('b')入栈
> + 输出b，执行完成，出栈
> + console.log('a')入栈，执行，输出a，出栈
> + 函数a执行完成，出栈。

**事件队列**：异步代码的执行，**遇到异步事件不会等待它返回结果，而是将这个事件挂起**，继续执行**执行栈中的其他任务**。当异步事件返回结果，将它放到事件队列中，**被放入事件队列不会立即执行起回调，而是等待当前执行栈中所有任务都执行完毕**，主线程空闲状态，主线程会去查找事件队列中是否有任务，如果有，**则取出排在第一位的事件**，并把这个事件对应的回调放到执行栈中，然后执行其中的同步代码。

在上面的基础上添加异步事件

```javascript
function a() {
  b();
  console.log('a')
}

function b() {
  console.log('b')
  setTimeout(function () {
    console.log('c')
  },2000)
}

a()
```

下图做总结：

<img src="https://segmentfault.com/img/remote/1460000022805532" alt="执行栈和事件队列" style="zoom:67%;" />

**宏任务和微任务**

为什么要引入微任务，只有一种类型的任务不行吗？

页面渲染事件，各种IO的完成事件等随时被添加到任务队列中，一直会保持先进先出的原则执行，我们不能准确地控制这些事件被添加到任务队列中的位置。但是这个时候突然有高优先级的任务需要尽快执行，那么一种类型的任务就不合适了，所以引入了微任务队列。

不同的异步任务被分为：宏任务和微任务。

**宏任务**：

> + script(整体代码)
> + setTimeout()
> + setInterval()
> + postMessage
> + I/O
> + UI交互事件

微任务：

> + new Promise().then(回调)
> + MutationObserver(HTML5新特性)

**运行机制**

异步任务的返回结果会被放到一个任务队列中，根据异步事件的类型，这个事件实际上会被放到对应的宏任务和微任务队列中去。

在当前执行栈为空时，主线程会查看微任务队列是否有事件存在

+ 存在：依次执行队列中的事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的事件，把当前的回调加到当前执行栈
+ 不存在：再去宏任务队列中取出一个事件并把对应的事件加入当前执行栈

当前执行栈执行完毕后会立刻处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件，同一次事件循环中，微任务永远在宏任务之前执行。

在事件循环中，每进行一次循环操作成为tick，每一次tick的任务处理模型时比较复杂的，但是关键步骤如下：

> + 执行一个宏任务（栈中没有就从事件队列中获取）
> + 执行过程中如果遇到微任务，就把它添加到微任务的任务队列中
> + 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
> + 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
> + 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）

简单总结一下执行的顺序：

执行宏任务，然后执行宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，再回到宏任务中进行下一轮循环。

![宏任务和微任务](https://segmentfault.com/img/remote/1460000022805533)

```javascript
console.log('start')

setTimeout(() => {
    console.log('setTimeout')
}, 0)

Promise.resolve().then(() => {
    console.log('promise1')
}).then(() => {
    console.log('promise2')
})
console.log('end')
```

> 1. 全局代码压入执行栈行，输出start
> 2. setTimeout压入macrotask队列，promise.then回调放入microtask队列，最后执行console.log('end')，输出end
> 3. 调用栈中的代码执行完成（全局代码属于宏任务），接下来开始执行微任务队列中的代码，执行promise回调，输出promise1，promise回调函数默认返回undefined,promise状态变为fulfilled，触发接下来的then回调，继续压入microtask队列，此时产生了新的微任务，会接着把当前的微任务队列执行完，此时执行第二个promise.then回调，输出promise2
> 4. 此时，microtask队列已清空，接下来会执行UI渲染工作（如果有的话），然后开始下一轮事件循环，执行setTimeout的回调，输出setTimeout

#### 9.3 node环境下的事件循环

**和浏览器环境的不同**

表现出的状态和浏览器大致相同，不同的是node中有一套自己的模型。node中事件循环的实现依赖libuv引擎。Node的事件循环存在几个阶段。

如果是node10及其之前版本，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列中的任务。

node版本更新到11以后，eventloop运行原理发生了变化，一旦执行一个阶段里的宏任务（setTimeout,setInterval和setImmediate）就立刻执行微任务队列，跟浏览器趋于一致。下面例子中的代码是按最新的去进行分析的。

**事件循环模型**

```markdown
┌───────────────────────┐
┌─>│        timers         │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     I/O callbacks     │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle, prepare     │
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │   incoming:   │
│  │         poll          │<──connections───     │
│  └──────────┬────────────┘      │   data, etc.  │
│  ┌──────────┴────────────┐      └───────────────┘
│  │        check          │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks    │
   └───────────────────────┘
```

**事件循环各阶段讲解**

node中事件循环的顺序

外部输入数据-->轮询阶段(poll)-->检查阶段(check)-->关闭事件回调阶段(close callback)-->定时器检查阶段(timer)-->I/O事件回调阶段(I/O callbacks)-->闲置阶段(idle,prepare)-->轮询阶段......

这些阶段大致的功能如下：

+ 定时器检测阶段（timers）：这个阶段执行定时器队列中的回调如setTimeout()和setInterval().
+ I/O事件回调阶段（I/O callbacks）：这个阶段执行几乎所有的回调，但是不包括close事件，定时器和setImmediate()的回调。
+ 闲置阶段（idle,prepare）：这个阶段仅在内部使用，可以不必理会。
+ 轮询阶段（poll）：等待新的I/O事件，node在一些特殊情况下会阻塞在这里。
+ 检查阶段（check）：setImmediate()的回调会在这个阶段执行。
+ 关闭事件回调阶段（close callbacks）：例如socket.on('close')这种close事件的回调

poll：
这个阶段是轮询时间，用于等待还未返回的 I/O 事件，比如服务器的回应、用户移动鼠标等等。
这个阶段的时间会比较长。如果没有其他异步任务要处理（比如到期的定时器），会一直停留在这个阶段，等待 I/O 请求返回结果。
check:
该阶段执行setImmediate()的回调函数。

close:
该阶段执行关闭请求的回调函数，比如socket.on('close', ...)。

timer阶段:
这个是定时器阶段，处理setTimeout()和setInterval()的回调函数。进入这个阶段后，主线程会检查一下当前时间，是否满足定时器的条件。如果满足就执行回调函数，否则就离开这个阶段。

I/O callback阶段：
除了以下的回调函数，其他都在这个阶段执行：

- setTimeout()和setInterval()的回调函数
- setImmediate()的回调函数
- 用于关闭请求的回调函数，比如socket.on('close', ...)

**宏任务和微任务**

宏任务：

> + setImmediate
> + setTimeout
> + setInterval
> +  script（整体代码)
> +  I/O 操作等。

微任务：

> + process.nextTick
> + new Promise().then(回调)

#### 9.4 经典题目分析

```javascript
async function async1() {
  console.log('async start')
  await async2();
  console.log('async1 end')
}

async function async2() {
  console.log('async2')
}
console.log('script start')
setTimeout(function () {
  console.log('setTimeout')
}, 0)
async1()
new Promise(function(resolve) {
  console.log('promise1')
  resolve()
}).then(function() {
  console.log('promise2')
})
console.log('script end')
```

> 先执行宏任务（当前代码块也算是宏任务），然后执行当前宏任务产生的微任务，然后接着执行宏任务
>
> 1. 先从上往下执行代码，先执行同步代码，输出script start
> 2. 遇到setTimeout，先把setTimeout的代码放到宏任务队列中
> 3. 执行async1()，输出async1 start，然后执行async2()，输出async2，把async2()后面的代码console.log('async1 end')放到微任务队列中
> 4. 接着往下执行，输出promise1，把.then()放到微任务队列中；注意Promise对象本身是同步的立即执行函数，.then是异步执行函数
> 5. 接着往下执行，输出script end。同步代码（同时也是宏任务）执行完成，接下来开始执行刚才放到微任务队列中的代码
> 6. 依次执行微任务中的代码，依次输出async end1、promise2，微任务中的代码执行完成后，开始执行宏任务中的代码，输出setTimeout

最后的执行结果如下：

- script start
- async1 start
- async2
- promise1
- script end
- async1 end
- promise2
- setTimeout

```javascript
console.log('start');
setTimeout(() => {
    console.log('children2');
    Promise.resolve().then(() => {
        console.log('children3');
    })
}, 0);

new Promise(function(resolve, reject) {
    console.log('children4');
    setTimeout(function() {
        console.log('children5');
        resolve('children6')
    }, 0)
}).then((res) => {
    console.log('children7');
    setTimeout(() => {
        console.log(res);
    }, 0)
})
```

这段代码中会执行多个宏任务，宏任务中又会有很多微任务

> 1. 从上往下执行代码，先执行同步代码，输出start
> 2. 遇到setTimeout，先把setTimeout的代码放到宏任务队列1中
> 3. 接着往下执行，输出children4，然后把setTimeout的代码放到宏任务队列2中
> 4. 代码执行完成以后，会查找微任务队列中的事件，发现并没有，于是开始执行宏任务1，即第一个setTimeout，输出children2，此时会把Promise.resolve().then()放到微任务队列中
> 5. 宏任务1中的代码执行完成后，会检查微任务队列，于是输出children3，然后开始执行宏任务2，即第二个setTimeout，输出children5，此时将then放到微任务队列中
> 6. 宏任务2中代码执行完成后，查找微任务队列，于是输出children7，然后输出children6

最后的执行结果如下：

- start
- children4
- children2
- children3
- children5
- children7
- children6

```javascript
const p = function() {
    return new Promise((resolve, reject) => {
        const p1 = new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve(1)
            }, 0)
            resolve(2)
        })
        p1.then((res) => {
            console.log(res);
        })
        console.log(3);
        resolve(4);
    })
}


p().then((res) => {
    console.log(res);
})
console.log('end');
```

> 1. 执行代码，Promise本身是同步的立即执行函数，.then是异步执行函数。遇到setTimeout，先把其放入宏任务队列中，遇到p1.then会先放到微任务队列中，然后输出3
> 2. 然后p().then放到微任务队列中，输出end
> 3. 然后检查微任务，输出p1().then结果2，然后输出p().then结果4
> 4. 由于p1.then()已经执行完毕，因此setTimeout的resolve不起作用了，结束


### 10.1  基本数据类型 引用数据类型 及区别

+ 基本数据类型：数字型，字符串型，null，undefinned，布尔型
+ 引用数据类型：对象（数组，正则，函数）
+ 区别：基本数据类型实际数据放在栈中，而引用数据类型的实际数据放在堆内存中

（栈：自动分配内存空间，由系统自动释放； 堆：动态分配内存空间，大小也不一定会释放）

### 10.2 判断数据类型的方法

#### 

 	在 ECMAScript 规范中，共定义了 7 种数据类型，分为 基本类型 和 引用类型 两大类，如下所示：

> **基本类型**：String、Number、Boolean、Symbol、Undefined、Null 
>
> **引用类型**：Object

​	基本类型也称为简单类型，由于其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈中，即按值访问。

​	引用类型也称为复杂类型，由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此，其值存储在堆(heap)中，而存储在变量处的	值，是一个指针，指向存储对象的内存处，即按址访问。引用类型除 Object 外，还包括 Function 、Array、RegExp、Date 等等。

​	鉴于 ECMAScript 是松散类型的，因此需要有一种手段来检测给定变量的数据类型。对于这个问题，JavaScript 也提供了多种方法，但遗憾的是，不同的方法得到的结果参差不齐。

​	下面介绍常用的4种方法，并对各个方法存在的问题进行简单的分析。

+ **1、typeof**

typeof 是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型。返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 7 种：number、boolean、symbol、string、object、undefined、function 等。

```
typeof``''``;``// string 有效``typeof``1;``// number 有效``typeof``Symbol();``// symbol 有效``typeof``true``;``//boolean 有效``typeof``undefined;``//undefined 有效``typeof``null``;``//object 无效``typeof``[] ;``//object 无效``typeof``new``Function();``// function 有效``typeof``new``Date();``//object 无效``typeof``new``RegExp();``//object 无效
```

有些时候，typeof 操作符会返回一些令人迷惑但技术上却正确的值：

- 对于基本类型，除 null 以外，均可以返回正确的结果。
- 对于引用类型，除 function 以外，一律返回 object 类型。
- 对于 null ，返回 object 类型。
- 对于 function 返回  function 类型。

其中，null 有属于自己的数据类型 Null ， 引用类型中的 数组、日期、正则 也都有属于自己的具体类型，而 typeof 对于这些类型的处理，只返回了处于其原型链最顶端的 Object 类型，没有错，但不是我们想要的结果。

+ **2、instanceof**

instanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。 在这里需要特别注意的是：**instanceof 检测的是原型**，我们用一段伪代码来模拟其内部执行过程：

```
instanceof (A,B) = {``  ``var``L = A.__proto__;``  ``var``R = B.prototype;``  ``if``(L === R) {``    ``// A的内部属性 __proto__ 指向 B 的原型对象``    ``return``true``;``  ``}``  ``return``false``;``}
```

从上述过程可以看出，当 A 的 __proto__ 指向 B 的 prototype 时，就认为 A 就是 B 的实例，我们再来看几个例子：

```
[] instanceof Array;``// true``{} instanceof Object;``// true``new``Date() instanceof Date;``// true` `function Person(){};``new``Person() instanceof Person;` `[] instanceof Object;``// true``new``Date() instanceof Object;``// true``new``Person instanceof Object;``// true
```

我们发现，虽然 instanceof 能够判断出 [ ] 是Array的实例，但它认为 [ ] 也是Object的实例，为什么呢？

我们来分析一下 [ ]、Array、Object 三者之间的关系：

从 instanceof 能够判断出 [ ].__proto__  指向 Array.prototype，而 Array.prototype.__proto__ 又指向了Object.prototype，最终 Object.prototype.__proto__ 指向了null，标志着原型链的结束。因此，[]、Array、Object 就在内部形成了一条原型链：

![img](https://images2015.cnblogs.com/blog/849589/201601/849589-20160112232510850-2003340583.png)

从原型链可以看出，[] 的 __proto__  直接指向Array.prototype，间接指向 Object.prototype，所以按照 instanceof 的判断规则，[] 就是Object的实例。依次类推，类似的 new Date()、new Person() 也会形成一条对应的原型链 。因此，**instanceof 只能用来判断两个对象是否属于实例关系****， 而不能判断一个对象实例具体属于哪种类型。**

instanceof 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。

```
var``iframe = document.createElement(``'iframe'``);``document.body.appendChild(iframe);``xArray = window.frames[0].Array;``var``arr =``new``xArray(1,2,3);``// [1,2,3]``arr instanceof Array;``// false
```

针对数组的这个问题，ES5 提供了 Array.isArray() 方法 。该方法用以确认某个对象本身是否为 Array 类型，而不区分该对象在哪个环境中创建。

```
if``(Array.isArray(value)){``  ``//对数组执行某些操作``}
```

Array.isArray() 本质上检测的是对象的 [[Class]] 值，[[Class]] 是对象的一个内部属性，里面包含了对象的类型信息，其格式为 [object Xxx] ，Xxx 就是对应的具体类型 。对于数组而言，[[Class]] 的值就是 [object Array] 。

+ **3、constructor**

当一个函数 F被定义时，JS引擎会为F添加 prototype 原型，然后再在 prototype上添加一个 constructor 属性，并让其指向 F 的引用。如下所示：

![img](https://images2015.cnblogs.com/blog/849589/201705/849589-20170508125250566-1896556617.png)

当执行 var f = new F() 时，F 被当成了构造函数，f 是F的实例对象，此时 F 原型上的 constructor 传递到了 f 上，因此 f.constructor == F

![img](https://images2015.cnblogs.com/blog/849589/201705/849589-20170508125714941-1649387639.png)

可以看出，F 利用原型对象上的 constructor 引用了自身，当 F 作为构造函数来创建对象时，原型上的 constructor 就被遗传到了新创建的对象上， 从原型链角度讲，构造函数 F 就是新对象的类型。这样做的意义是，让新对象在诞生以后，就具有可追溯的数据类型。

同样，JavaScript 中的内置对象在内部构建时也是这样做的：

![img](https://images2015.cnblogs.com/blog/849589/201705/849589-20170508131800457-2091987664.png)

**细节问题：**

> \1. null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。
>
> \2. 函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object

![img](https://images2015.cnblogs.com/blog/849589/201705/849589-20170508132757347-1999338357.png)

为什么变成了 Object？

因为 prototype 被重新赋值的是一个 { }， { } 是 new Object() 的字面量，因此 new Object() 会将 Object 原型上的 constructor 传递给 { }，也就是 Object 本身。

因此，为了规范开发，在重写对象原型时一般都需要重新给 constructor 赋值，以保证对象实例的类型不被篡改。

+ **4、toString**

toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。

对于 Object 对象，直接调用 toString() 就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。

```
Object.prototype.toString.call(``''``) ; ``// [object String]``Object.prototype.toString.call(1) ;  ``// [object Number]``Object.prototype.toString.call(``true``) ;``// [object Boolean]``Object.prototype.toString.call(Symbol());``//[object Symbol]``Object.prototype.toString.call(undefined) ;``// [object Undefined]``Object.prototype.toString.call(``null``) ;``// [object Null]``Object.prototype.toString.call(``new``Function()) ;``// [object Function]``Object.prototype.toString.call(``new``Date()) ;``// [object Date]``Object.prototype.toString.call([]) ;``// [object Array]``Object.prototype.toString.call(``new``RegExp()) ;``// [object RegExp]``Object.prototype.toString.call(``new``Error()) ;``// [object Error]``Object.prototype.toString.call(document) ;``// [object HTMLDocument]``Object.prototype.toString.call(window) ;``//[object global] window 是全局对象 global 的引用
```

 

### 11.   微任务

+ 异步任务分为宏任务、微任务
+ 宏任务：整个script，settimeout，setinterval
+ 微任务：promise，process.nextTick
+ 在执行过程中（首先就是执行一个宏任务），碰到宏任务会被放入宏任务队列中，微任务会被放入微任务队列中，主线程执行完毕，先查看微任务队列，执行完进行渲染，再看宏任务队列，进行第二次循环。

### 12.  js数组扁平化

+ toString split map

### 13. Set的各种方法

+ 集合
+ 创建:  new Set();     new Set([1,2,3]);
+ 添加：v.add(2)
+ 大小：v.size
+ 删除：v.delete()
+ 是否有某个元素：v.has()
+ 遍历：for of;  forEach

### 14. Map的各种方法

+ 创建： new Map()    或传入一个二维数组
+ 添加：v.set( 'hallo' , 100 )
+ 删除：v.delete('hello')
+ 是否有某个元素：v.has('hello')
+ 获取： v.get('value')

### 15.1 Set Map 的区别

+ map是键值对，set是值的集合
+ map一般用于存储数据，set值不能重复，因此可以用于数组去重
+ map可以用get获取对应的值，set 没有get这个方法

### 15.2  forEach map 的区别

+ 相同点：
  + 都是循环遍历数组中的每一项
  + forEach和map方法里每次执行匿名函数都支持3个参数，参数分别是item（当前每一项）、index（索引值）、arr（原数组）
  + 匿名函数中的this都是指向window
  + 只能遍历数组
+ 不同点
  + forEach ( ) 没有返回值。forEach 适合于你并不打算改变数据的时候，而只是想用数据做一些事情 – 比如存入数据库或则打印出来。
  + map ( ) 有返回值，可以return 出来。map()适用于你要改变数据值的时候。

```csharp
let arr = [1, 2, 3, 4, 5];
let arr2 = arr.map(value => value * value).filter(value => value > 10);
// arr2 = [16, 25]
```

​	我们首先使用map将每一个元素乘以它们自身，然后紧接着筛选出那些大于10的元素。最终结果赋值给arr2。

### 16.  js数组方法，哪些可以改变数组本身

+ 数组转字符串：arr.toString( );   arr.join(' ');
  + 不改变数组本身
+ 四个方法：arr.push( ); arr.pop( ); arr.unshift( ); arr.shift( );
  + pop,shift 返回被删除的元素，push，unshift 返回新数组长度
  + 他们都会改变原数组
+ 更改元素：arr[index] = n
  + 更改原数组
+ 末尾追加元素：arr[arr.length] = n (相当于push，也会改变数组本身)
+ 删除元素： delete arr[index] 或直接删除数组 ：delete arr
  + 会改变数组本身，删除元素的位置空出来undefined
+ arr.concat( );  arr.slice( ); arr.splice( );
  + arr.concat(arr1, arr2) 或 arr.concat( 'gf', 'hj' ); (不改变原数组)
  + arr.slice( ); 截取，从第几个到第几个，省略第二个表示到最后。（不改变原数组）
  + arr.splice( ); 第一个是从哪里开始，第二个是删除几个，后面的全是添加的元素
    + 返回删除的元素，改变原数组

### 17.  栈，队列，链表（js如何实现）（0）



### 18.  order的理解（0）



### 19.  什么是闭包，哪里用到了闭包（怎么验证不回收）

+ 闭包就是能够读取其他函数内部变量的函数。

+ 闭包简介：

  + **变量的作用域**

  要理解闭包，首先必须理解Javascript特殊的变量作用域。

  变量的作用域无非就是两种：全局变量和局部变量。

  Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。

  在函数外部自然无法读取函数内的局部变量。

  这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！

  + **如何从外部读取局部变量？**

  出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。

  那就是在函数的内部，再定义一个函数。

  > 　　function f1(){
  >
  > 　　　　var n=999;
  >
  > 　　　　function f2(){
  > 　　　　　　alert(n); // 999
  > 　　　　}
  >
  > 　　}

  在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的"链式作用域"结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。

  既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！

  > 　　function f1(){
  >
  > 　　　　var n=999;
  >
  > 　　　　function f2(){
  > 　　　　　　alert(n);
  > 　　　　}
  >
  > 　　　　return f2;
  >
  > 　　}
  >
  > 　　var result=f1();
  >
  > 　　result(); // 999

  + **闭包的概念**

  上一节代码中的f2函数，就是闭包。

  闭包就是能够读取其他函数内部变量的函数。

  由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成"定义在一个函数内部的函数"。

  所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。

  + **闭包的用途**

  闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。

  + **使用闭包的注意点**

  1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。

  2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

#### **闭包面试题（一）**

https://www.cnblogs.com/xxcanghai/p/4991870.html

### 20.1  es6新特性(promise待补充)

+ **1.  let const**

+ **2.  字符串扩展**

  + **字符串 API**

    在ES6中，为字符串扩展了几个新的API

    - includes(“xxx”)：返回布尔值，表示是否包含**xxx**
    - startsWith(“xxx”)：返回布尔值，表示是否以**xxx**开头
    - endsWith(“xxx”)：返回布尔值,表示是否以**xxx**结尾

    示例：

    ```js
    let str = "Hello Javascript";
    console.log(str, "中是否包含 hello ==>", str.includes("hello"));
    console.log(str, "中是否包含 hi ==>", str.includes("hi"));
    
    console.log(str, "中是否以 h 开头==>", str.startsWith("h"));
    console.log(str, "中是否以 a 开头==>", str.startsWith("a"));
    
    console.log(str, "中是否以 a 结尾==>", str.endsWith("a"));
    console.log(str, "中是否以 t 结尾==>", str.endsWith("t"));
    ```

    输出结果：

    <img src="https://i.loli.net/2020/09/02/n6yMSCvrNBI7Ffo.png" alt="img"  />

  + **字符串模板**

    ES6中提供了`来作为字符串模板标记。

    示例：

    ```js
    <script type="text/javascript">
        let str = `
        hello
        Java
        and
        JavaScript
        `;
        console.log(str);
    </script>
    ```

    输出结果：

    ![img](https://i.loli.net/2020/09/02/9IHCRZdNGb5sTnB.png)

    两个`之间的部分都会被记做字符串的值，可以任意换行。

+ **3.  解构表达式**

   ES6中允许安装一定模式从数组对象中提取值，然后对变量进行赋值，这样被称之为解构

  + **数组解构**

    例如，有一个数组

    ```js
    let arr = [1,2,3]
    ```

    之前，想要获取其中的值，只能通过下标。但ES6可以这样做：

    ```js
    let arr = [1,2,3];
    const [a,b,c] = arr;	// a,b,c将与arr中的每个位置对应来取值
    console.log(a,b,c);
    const [x] = arr;	// 只匹配一个参数值
    console.log(x);
    ```

    结果：

    ![img](https://i.loli.net/2020/09/03/azQPAOCpdvRU4eM.png)

  + **对象解构**

    例如，定义一个对象

    ```js
    const person = {
        name: "Tom",
        age: 20,
        language: ['Java','JavaScript','Python']
    }
    ```

    使用解构表达式取值：

    ```js
    const {name,age,language} = person;		// {}内的属性名必须是person的属性名
    console.log(name);
    console.log(age);
    console.log(language);
    
    // 如果想用其他变量接收，需要指定别名
    const {name:n} = person;
    console.log("n: ",n);
    ```

    结果：

    ![img](https://i.loli.net/2020/09/03/P9nr67dZJ4akvzB.png)

+ **4.  函数优化**

  + **函数默认值**

    在ES6之前，无法给一个函数参数设置默认值，只能采用变通写法：

    ```js
    // 如果没有给参数b传值，则b=1
    function add(a,b){
        b = b || 1;
        return a+b;
    }
    console.log(add(10));	//输出11
    console.log(add(10，20));	//输出30
    ```

    使用了ES6之后，可以这样写

    ```js
    function add(a,b = 1){
        return a+b;
    }
    console.log(add(10));	//输出11
    console.log(add(10，20));	//输出30
    ```

  + **箭头函数**

  + **对象的函数属性简写**

    比如有一个`Person`对象，里面有`eat()`方法

    ```js
    let person = {
        name: "Tom",
        // ES6之前
        eat: function (food){
            console.log(this.name + "在吃" + food);
        }
        // 箭头函数写法
        eat2: food => console.log(person.name + "在吃" + food);
    	// 简写版
    	eat3(food){
            console.log(this.name + "在吃" + food);
        }
    }
    ```

  + **箭头函数结合解构表达式**

    例如，有这样一个函数

    ```js
    const person = {
        name: "Tom",
        age: 20,
        language: ["Java","Python","JS"]
    }
    function hello(person){
        console.log("Hello," + person.name);
    }
    ```

    使用箭头函数和解构表达式的写法

    ```js
    var hi = ({name}) => console.log("hello," + name);
    hi(person);
    ```

+ **5.  数组新增 map 和 reduce 方法**

  + **map（）**

    `map()`：接收一个函数，将原数组中的所有元素用这个函数处理后放入新的数组返回。

    例如：有一个字符串数组，要求把它转换为int数组

    ```js
    let arr = ['1','2','3','4']
    console.log(arr);
    
    let newArr = arr.map(s => parseInt(s));
    console.log(newArr);
    ```

    结果：

    ![img](https://i.loli.net/2020/09/03/FQBpYvEu8NOUHLf.png)

  + **reduce（）**

    `reduce()`：接收一个函数（必须）和一个初始值（可选），该函数接收两个参数：

    - 第一个参数是上一次reduce处理的结果，
    - 第二个参数是数组中要处理的下一个元素

    `reduce()`会从左至右依次把数组中的元素用reduce()处理，并把处理结果作为下一次reduce的第一个参数，如果是第一次，会把前两个元素作为计算参数，或者把传入的初始值参数作为起始值。

    例如：

    ```js
    const arr = [2,5,-10,20]; 
    ```

    没有指定初始值：

    ![img](https://i.loli.net/2020/09/03/rN6QChyEGsBVdjc.png)

    指定了初始值：

    ![img](https://i.loli.net/2020/09/03/tg6xHwXaCemYOZK.png)

+ **6.  运算符扩展**

  扩展运算符（spread）是三个点（…），将一个数组转为用逗号分隔的参数序列。

  用法：

  ```js
  console.log(...[1,2,3]);        // 1 2 3
  console.log(1,...[2,3,4],5);    // 1 2 3 4 5
  
  function add(x,y) {
      return x+y;
  }
  const number = [1, 2];
  console.log(add(...number));    // 3
  
  let arr = [...[1,2,3],...[4,5,6]];
  console.log(arr);   //[1,2,3,4,5,6]
  
  const [first,...rest] = [1,2,3,4,5,6];
  console.log(first,rest);    // 1 [2,3,4,5,6]
  
  console.log([..."hello"]);  // ["h","e","l","l","o"]
  ```

  ![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDkvMDMvUE5KVnYyWWdqaGVNYlJsLnBuZw?x-oss-process=image/format,png)

+ **7.  Promise**

+ **8.  Set Map 数据结构**

  + **Set**
  + **Map**

+ **9.  class（类）的基本语法**（继承）

  JavaScript的传统方法是通过构造函数定义并生成对象。ES6中引入了`class`的概念，通过`class`关键字自定义类。

  ```js
  <script type="text/javascript">
      class User{
          // 构造函数
          constructor(name,age = 20){
              this.name = name;
              this.age = age;
          }
          // 定义方法
          sayHello(){
              return "Hello: " + this.name;
          }
          // 静态方法
          static isAdult(age){
              if (age >= 18){
                  return " 成年 " + age;
              }
              return " 未成年 " + age;
  
          }
      }
      let user = new User("Tom",23);
      console.log(user);
      console.log(user.sayHello());
      // 静态方法需要使用类来调用
      console.log(User.isAdult(user.age));
  </script>
  ```

  结果：

  ![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDkvMDQvSUtqTTZxSkhDUmF2VFBjLnBuZw?x-oss-process=image/format,png)

+ **10.  Generator函数**

  `generator`是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。

  `Generator`函数有**两个**特征

  - function命令与函数名之间有一个*****号
  - 函数体内部使用yield语句定义不同的内部状态

  用法：

  ```js
  <script type="text/javascript">
      function * hello() {
          yield "hello";
          yield "world";
          return "over"
      }
      let hi = hello();
      console.log(hi.next());
      console.log(hi.next());
      console.log(hi.next());
      console.log(hi.next());
  </script>
  ```

  结果：

  ![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDkvMDQvd21UZktpVzc0eFJWekVBLnBuZw?x-oss-process=image/format,png)

  可以看到，通过hello()返回的hi对象，每调用一次`next()`方法返回一个对象，该对象包含了value值和done状态。知道遇到`return`关键字或者函数执行完毕，这个时候返回的done状态为true，表示已经执行完毕。

+ **11.  for...of 循环**

  通过for…of可以循环遍历Generator函数返回的迭代器。

  用法：

  ```js
  <script type="text/javascript">
      function * hello() {
          yield "hello";
          yield "world";
          return "over"
      }
      let hi = hello();
      for (let obj of hi) {
          console.log(obj);
      }
  </script>
  ```

  输出结果：

  ![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDkvMDQvOXd6Sk8yM0hHVTQxSUF5LnBuZw?x-oss-process=image/format,png)

### 20.2  es6字符串特性（）

+ **新的API方法：字符串检测**

  三种新方法检查另一个字符串中是否存在字符串：

```text
> 'hello'.startsWith('hell') // 返回布尔值，表示参数字符串是否在原字符串的头部
true
> 'hello'.endsWith('ello') // 返回布尔值，表示参数字符串是否在原字符串的尾部。
true
> 'hello'.includes('ell') // 返回布尔值，表示是否找到了参数字符串
true
```

​	这些方法都有一个可选的第二个参数，该参数指定要搜索的字符串开始或结束的位置：

```text
> 'hello'.startsWith('ello', 1)
true
> 'hello'.endsWith('hell', 4)
true

> 'hello'.includes('ell', 1)
true
> 'hello'.includes('ell', 2)
false
```

+ **字符串复制**

  repeat（）方法重复字符串.

```text
> 'doo '.repeat(3) // 返回一个新字符串，表示将原字符串重复n次
'doo doo doo '
```

​	除了上述新增加的的API,ES6关于字符串还增加了一种新的表示方法---模板字符串

```text
格式：``
// String interpolation via template literals (in backticks)
// 通过${}插入变量
const first = 'Jane';
const last = 'Doe';
console.log(`Hello ${first} ${last}!`);
    // Hello Jane Doe!

// Template literals also let you create strings with multiple lines
// 支持多行字符串
const multiLine = `
This is
a string
with multiple
lines`;
```

+ **Unicode码点转义**

  在ECMAScript 6中，有一种新的Unicode转义，可让您指定任何代码点（甚至是那些超过16位的代码点）：

```text
console.log('\u{1F680}');    // ES6: single code point
console.log('\uD83D\uDE80'); // ES5: two code units
```

+ **模板字符串和String.raw()**

关于模板字符串我会开一篇文章专门介绍.这里主要介绍模板字符串三个特性、

​		支持字符串插值

```text
const first = 'Jane';
const last = 'Doe';
console.log(`Hello ${first} ${last}!`);
    // Hello Jane Doe!
```

​		支持多行字符串表示方式

```text
const multiLine = `
This is
a string
with multiple
lines`;
```

​		ES6 为原生的 String 对象，提供了一个`raw`方法。`String.raw`方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。

```text
const str = String.raw`Not a newline: \n`;
console.log(str === 'Not a newline: \\n'); // true
```

+ **迭代字符串**

  字符串是可迭代的，这意味着您可以使用for-of遍历它们的字符：

```text
for (const ch of 'abc') {
    console.log(ch);
}
// Output:
// a
// b
// c
```

​	同样你可以使用扩展运算符（...）将字符串转换为数组：

```text
const chars = [...'abc'];
    // ['a', 'b', 'c']
```

+ **Unicode代码点同样是可以迭代的。**

  字符串迭代器沿着代码点边界分割字符串，这意味着它返回的字符串包含一个或两个JavaScript字符：

```text
for (const ch of 'x\uD83D\uDE80y') {
    console.log(ch.length);
}
// Output:
// 1
// 2
// 1
```

+ **计算代码点长度**

  迭代器为您提供了一种快速计算字符串中Unicode代码点的方法：

```text
> [...'x\uD83D\uDE80y'].length
3
```

+ **颠倒非BMP代码点的字符串**

  迭代器还可以反转包含非BMP代码点（大于16位并编码为两个JavaScript字符）的字符串：

```text
const str = 'x\uD83D\uDE80y';

// ES5: \uD83D\uDE80 are (incorrectly) reversed
console.log(str.split('').reverse().join(''));
    // 'y\uDE80\uD83Dx'

// ES6: order of \uD83D\uDE80 is preserved
console.log([...str].reverse().join(''));
    // 'y\uD83D\uDE80x'
```

![img](https://pic1.zhimg.com/80/v2-1813dd97ed4aa138add21070de52ecbc_720w.jpg)

+ **codePointAt**

  ES6 提供了`codePointAt`方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。

```text
const str = 'x\uD83D\uDE80y';
console.log(str.codePointAt(0).toString(16)); // 78
console.log(str.codePointAt(1).toString(16)); // 1f680
console.log(str.codePointAt(3).toString(16)); // 79
```

​	该方法配合字符串迭代遍历使用非常方便:

```text
for (const ch of 'x\uD83D\uDE80y') {
    console.log(ch.codePointAt(0).toString(16));
}
// Output:
// 78
// 1f680
// 79
```

​	codePointAt（）的相反方法是String.fromCodePoint（）：

```text
> String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\uD83D\uDE80y'
true
```

### 21.  递归可以转换成迭代吗（0）



### 22.  TS 对比 JS （0）



### 23.  JS怎么实现类型检查



### 24.  开发PC端页面和移动端页面分别要考虑什么问题



### 25.  如何构造类



### 26.1  事件冒泡和事件代理

### 26.2  阻止事件冒泡两种方式

+ stopPropogation, return false

### 27.  删除一个DOM节点的方法



### 28.  给两个数组，去重，合并!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



### 29. js实现继承

+ 1. 原型式继承

  function Son() {

  }

  Son.prototype = new Parent();

  Son.prototype.constructor = Son;

  + 把子类的原型对象赋值给父类的实例，此时可以使用父类的属性和方法
  + 特点：由于子实例的属性和方法，都在父类同一个实例上，因此一个子实例修改，其他也会改

+ 2. 构造函数式继承

  function Son(color) {

    Parent.call(this, color);

  }

  + 利用构造函数进行继承，使用Parent.call将子类的this指向父类构造函数，就可以使用父类属性和方法
  + 特点：通过构造函数创造的实例对象，内部属性方法都独立，不会被其他实例影响

+ 3. 组合式继承

  + 是前两种的结合，把不想共享的属性和方法放在父构造函数内部，让子类使用call继承； 
  + 想共享的放在父类原型对象中，通过原型式来继承

+ 4. 寄生式继承

  var son = Object.create(obj);

  + 原型链式每次实例化对象的时候，都要调用一次父类构造函数
  + 是原型链式继承的改良版，他不需要构造函数，而且实现了属性的共享，

+ 5. 寄生组合式继承

  + 是组合式继承的改良版

  + 把不想共享的属性和方法放在父构造函数内部，让子类使用call继承；想共享的放在父类原型对象中，通过Object.create来继承

  Son.prototype = Object.create(Parent.prototype);

### 30. 浅拷贝与深拷贝（待补充）

+ 所谓拷贝，就是赋值。把一个变量赋给另外一个变量，就是把变量的内容进行拷贝。把一个对象的值赋给另外一个对象，就是把一个对象拷贝一份。

+ 对于基本数据类型来说，直接复制就可以，也就是所说的浅拷贝

+ 对于引用数据类型来说，由于存的是地址，直接浅拷贝，拷贝下来的是地址，不是数据，一个发生变化，其余也要变，也就是说，拷贝的深度不贵，因此需要深拷贝

+ ​    function deepCopy(newObj, oldObj) {

  ​      for (var k in oldObj) {

  ​        var item = oldObj[k];

  ​        if (item instanceof Array) {

  ​          newObj[k] = [];

  ​          deepCopy(newObj[k], item);

  ​        } else if (item instanceof Object) {

  ​          newObj[k] = {};

  ​          deepCopy(newObj[k], item);

  ​        } else {

  ​          newObj[k] = item;

  ​        }

  ​      }

  ​    }

### 31. settimeout怎么工作的，如果时间为零怎么办

+ settimeout 是异步任务，在碰到时，会被放入event table 中，等到了时间再推入事件队列中，当主线程执行完毕，空闲时，会执行事件队列中的settimeout
+ setinterval 也是异步任务，时间到了就推入事件队列，，再过这么长时间再推入，一直推。

### 32.1 let const var

+ var:
  + 声明的范围是函数作用域（函数调用结束后会销毁）
  + 存在变量提升
  + 可以反复声明

+ let:
  + 声明范围块级作用域
  + 不存在变量提升，有暂时性死区
  + 不可以反复声明

+ const:
  + 与let一样，不过声明时必须赋值，并且不能修改他的
  +  如果const是对象，可以修改对象内的属性

### 32.2  ES5怎么实现let,const

### 33. forEach()、map()、filter()、reduce()的用法

##### 1.forEach()

+ forEach方法循环数组中每一个元素并采取操作，没有返回值。它接受一个函数作为参数，这个函数接受三个参数：当前值、当前位置、整个数组。

```
let arr = [1, 2, 3];
arr.forEach(function( item, index, array){
    console.log(item+1, index)
})
//2 0
//3 1
//4 2
```

##### 2.map()

+ map方法遍历数组中每一个元素，有返回值，返回值是每一次执行的结果组成的新数组。不会改变原数组

+ map方法也是接受一个函数作为参数，这个函数接受三个参数：当前值、当前位置、整个数组。

```
let arr = [1, 2, 3];
let newArr = arr.map(function(item, index, array){
   return item*2; 
})
console.log(newArr)  //[2, 4, 6]
console.log(arr)  //[1, 2, 3]
```

##### 3.filter()

+ filter方法过滤数组成员，满足条件的成员组成一个新数组返回。filter也不会改变原数组。

```
let arr = [1, 2, 3, 4, 5];
let newArr = arr.filter(function(item, index, array){
        return item > 3
})
console.log(newArr, arr) //[4, 5], [1, 2, 3, 4, 5]
```

+ 由于map、filter的返回值是数组，因此也可以链式使用。

```
let arr = [1, 2, 3, 4];
let newArr = arr.map(function(item){
   return item*2 
}).filter(function(item){
   return item >= 6 
})
console.log(newArr)  //[6, 8]
```

##### 4.reduce()

+ reduce依次处理数组的成员，最终累计为一个值。

```
let arr = [1, 2, 3, 4, 5];
let newArr = arr.reduce(function(a, b){
  console.log(a, b);
  return a + b;  
}
console.log(arr)  //[1, 2, 3, 4, 5]
console.log(newArr)
// 1 2
// 3 3
// 6 4
// 10 5
//最后结果：15
```

+ 上面代码中 ，reduce方法求出数组所有成员的和。第一次执行，a、b分别是数组中的第一个成员1和第二个成员2。第二次执行，a为上一轮的返回值3，b为数组的第三个成员3。第三次执行，a为上一轮的返回值6，b为数组的第四个成员4。第四次执行，a为上轮的返回值10，b为数组的第五个成员5。至此所有成员遍历完成，整个方法的返回值就是最后一轮的返回值15。

### 34.1 数组常用方法（哪些改变原数组）

+ 转字符串：arr.toString( );   arr.join(' ');
  + 不改变数组本身
+ 四个方法：arr.push( ); arr.pop( ); arr.unshift( ); arr.shift( );
  + pop,shift 返回被删除的元素，push，unshift 返回新数组长度
  + 他们都会改变原数组
+ 更改元素：arr[index] = n
  + 更改原数组
+ 末尾追加元素：arr[arr.length] = n (相当于push，也会改变数组本身)
+ 删除元素： delete arr[index] 或直接删除数组 ：delete arr
  + 会改变数组本身，删除元素的位置空出来undefined
+ arr.concat( );  arr.slice( ); arr.splice( );
  + arr.concat(arr1, arr2) 或 arr.concat( 'gf', 'hj' ); (不改变原数组)
  + arr.slice( ); 截取，从第几个到第几个，省略第二个表示到最后。（不改变原数组）
  + arr.splice( ); 第一个是从哪里开始，第二个是删除几个，后面的全是添加的元素
    + 返回删除的元素，改变原数组

### 34.2 字符串常用方法

+ 1、**toLowerCase()**: 把字符串转为小写，返回新的字符串。

```
var str="Hello World";
var str1=str.toLowerCase();
console.log(str); //Hello World
console.log(str1); //hello world
```

+ 2、**toUpperCase()**: 把字符串转为大写，返回新的字符串。

```
var str="hello world";
var str1=str.toUpperCase();
console.log(str); //hello world
console.log(str1); //HELLO WORLD
```

+ 3、**charAt()**: 返回指定下标位置的字符。如果index不在0-str.length(不包含str.length)之间，返回空字符串。

```
var str="hello world";
var str1=str.charAt(6);
console.log(str1); 
```

+ 4、**charCodeAt()**: 返回指定下标位置的字符的unicode编码,这个返回值是 0 - 65535 之间的整数。

```
var str="hello world";
var str1=str.charCodeAt(1);
var str2=str.charCodeAt(-2); //NaN
console.log(str1); //101
```

注意：如果index不在0-str.length(不包含str.length)之间，返回NaN。

+ 5、**indexOf()**: 返回某个指定的子字符串在字符串中第一次出现的位置

```
var str="Hello World";
var str1=str.indexOf("o");
var str2=str.indexOf("world");
var str3=str.indexOf("o",str1+1);
console.log(str1); //4 默认只找第一个关键字位置，从下标0开始查找
console.log(str2); //-1 没有找到
console.log(str3); //7
```

注意：indexOf()方法对大小写敏感，如果子字符串没有找到，返回-1。第二个参数表示从哪个下标开始查找，没有写则默认从下标0开始查找。

+ 6、**lastIndexOf()**: 返回某个指定的子字符串在字符串中最后出现的位置。

```
var str="Hello World";
var str1=str.lastIndexOf("o");
var str2=str.lastIndexOf("world");
var str3=str.lastIndexOf("o",str1-1);
console.log(str1); //7
console.log(str2); //-1
console.log(str3); //4
```

注意：lastIndexOf()方法对大小写敏感，如果子字符串没有找到，返回-1。第二个参数表示从哪个下标开始查找，没有写则默认从最后一个字符处开始查找。

+ 7、**slice()**: 返回字符串中提取的子字符串。

```
var str="Hello World";
var str1=str.slice(2); //如果只有一个参数，则提取开始下标到结尾处的所有字符串
var str2=str.slice(2,7); //两个参数，提取下标为2，到下标为7但不包含下标为7的字符串
var str3=str.slice(-7,-2); //如果是负数，-1为字符串的最后一个字符。提取从下标-7开始到下标-2但不包含下标-2的字符串。前一个数要小于后一个数，否则返回空字符串

console.log(str1); //llo World
console.log(str2); //llo W
console.log(str3); //o Wor
```

+ 8、**substring()**: 提取字符串中介于两个指定下标之间的字符。

```
var str="Hello World";
var str1=str.substring(2)
var str2=str.substring(2,2);
var str3=str.substring(2,7);
console.log(str1); //llo World
console.log(str2); //如果两个参数相等，返回长度为0的空串
console.log(str3); //llo W
```

注意：substring()用法与slice()一样，但不接受负值的参数。

+ 9、**substr()**: 返回从指定下标开始指定长度的的子字符串

```
var str="Hello World";
var str1=str.substr(1)
var str2=str.substr(1,3);
var str3=str.substr(-3,2);
console.log(str1); //ello World 
console.log(str2); //ell
console.log(str3); //rl
```

注意：如果没有指定length,返回从下标开始处结尾处的所有字符串。

+ 10、**split()**: 把字符串分割成字符串数组。

```
var str="AA BB CC DD";
var string1="1:2:3:4:5";
var str1=str.split("");//如果把空字符串 ("")用作分割符，那么字符串的每个字符之间都会被分割
var str2=str.split(" "); //以空格为分隔符
var str3=str.split("",4); //4指定返回数组的最大长度
var str4=string1.split(":");
console.log(str1); // ["A", "A", " ", "B", "B", " ", "C", "C", " ", "D", "D"]
console.log(str2); //["AA" "BB" "CC" "DD"]
console.log(str3); //["A", "A", " ", "B"]
console.log(str4); // ["1", "2", "3", "4", "5"]
```

+ 11、**replace()**: 在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。

```
var str="hello WORLD";
var reg=/o/ig; //o为要替换的关键字，不能加引号，否则替换不生效，i忽略大小写，g表示全局查找。
var str1=str.replace(reg,"**")
console.log(str1); //hell** W**RLD
```

+ 12、**match()**: 返回所有查找的关键字内容的数组。

```
var str="To be or not to be";
var reg=/to/ig;
var str1=str.match(reg);
console.log(str1); //["To", "to"]
console.log(str.match("Hello")); //null
```

### 35. 暂时性死区

+ 只要块级作用域内 存在let命令，它所声明的变量就会“绑定”这个区域，不在受外部的影响。

  如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成封闭作用域。

  凡是在声明之前就使用这些变量，就会报错。 这就是暂时性死区

### 36. 作用域

> 任何程序设计语言都有作用域的概念，简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。
> 换句话说作用域决定了代码区块中变量和其他资源的可见性

让我们先来看个例子

```js
function fn() {
	var variable = "内部变量";
}
fn();//先执行函数
console.log(variable);//报错 variable is not defined
```

![img](https://pic2.zhimg.com/80/v2-c2de0c4967ac76936ff959e7d20af6e9_720w.png)

这里我们就可以看出作用域的概念，变量 variable 在函数 fn 内部声明，全局作用域没有声明，所以在全局作用域下访问 variable 会报错。

我们也可以这样理解：**作用域就是一个独立的区域，让变量不在泄露出去。它最大的作用就是隔离变量，使其不会受到污染**

在JavaScript中，变量的作用域有**全局作用域和局部作用域**两种。

```js
var a=20;
function fn(){
    var sum=0;
    alert(a);//20   局部访问全局
}
fn()//先执行
alert(sum)//报错  全局访问局部
```

![img](https://pic2.zhimg.com/v2-c0c158e23f5134fef2d319d6e8de743d_b.jpg)

上面这个例子我们可以看到**作用域的特点：局部可以访问全局的变量，但全局不能访问局部的变量**

+ 1、全局作用域

  全局作用域在任何地方都可以进行访问，函数的外面叫做全局作用域（不包括函数嵌套）

  在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域：

**（1）最外层函数和在最外层函数外面定义的变量拥有全局作用域，例如：**

```js
var sum = "全局变量"; //最外层变量
function fn() { //最外层函数
    var num = "局部变量";
    function Fun() { //内层函数
        alert('内层访问全局 '+ sum);
    }
    Fun();
}
alert('外层访问全局 ' + sum); //我是最外层变量
fn(); //内层变量
alert('外层访问局部 ' + num); //num is not defined
Fun(); //Fun is not defined
```

![img](https://pic4.zhimg.com/v2-2257939521326abab8b3038f3f870847_b.jpg)

**（2）所有末定义直接赋值的变量自动声明为拥有全局作用域，例如：**

```js
function outFun2() {
    num = "未定义直接赋值的变量";
    var sun = "局部变量";
}
outFun2();//先执行函数
alert(num); //未定义直接赋值的变量
alert(sun); //sun is not defined
```

![img](https://pic4.zhimg.com/v2-d18905e80a87f483b896cc4dbe1ded37_b.jpg)

**（3）所有window对象的属性拥有全局作用域**

​	一般情况下，window对象的内置属性都拥有全局作用域，例如window.name、window.location、window.top等等。

**全局作用域有个严重的弊端**：如果我们写了很多行 JS 代码，变量定义都定义在全局作用域中。这样就会 污染全局命名空间, 容易引起命名冲突。**造成变量污染**

```js
// a 写的代码
var num = 12;

// b 写的代码
var num = 10;

alert(num)// 10
```

+ 2、局部作用域

  局部作用域又叫做函数作用域，是指声明在函数内部的变量。和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部。

```js
function fn(){
    var num="局部变量";
    function Fun(){
        alert('内层访问局部 ' + num);//局部访问局部
    }
    Fun();
}
fn()
alert('外层访问局部 ' + num)
```

![img](https://pic2.zhimg.com/v2-e8caceb3814007117b79f8e5adac2339_b.jpg)

**总结：**

> 作用域特点：局部可以访问全局的变量，但全局不能访问局部的变量
> 全局作用域：在任何地方都可以进行访问，函数的外面叫做全局作用域（不包括函数嵌套）
> 局部作用域：函数内部的变量，只能在局部访问

### 37.  原型，原型链

+ **原型**
  + 每个构造函数都拥有一个 prototype 属性，它指向构造函数的原型对象，这个原型对象中有一个 construtor 属性指回构造函数；
  + 每个实例对象都有一个__proto__属性，当我们使用构造函数去创建实例时，实例的__proto__属性就会指向对应构造函数的原型对象。

```js
function Student(name,number) {
   this.name = name
   this.number = number
}
Student.prototype.sayHi = function () {
    console.log(`姓名:${this.name},学号:${this.number}`)
}
var xialuo = new Student("夏洛",23)
console.log(xialuo.name)     //夏洛
console.log(xialuo.number)   //23
xialuo.sayHi();  //姓名:夏洛,学号:23
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200108143342239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ3MzExNA==,size_16,color_FFFFFF,t_70)

​		xialuo是通过Student new出来的，所以xialuo的__proto__指向Student的prototype
​		xialuo.**proto** === Student.prototype

+ **查找规则**
  + 获取实例属性xialuo.name或执行实例方法xialuo.sayHi()时，先在自身属性和方法寻找，找不到则自动通过实例的__proto__到对应class的prototype(Student.prototype)中查找
+ **原型链**
  + 每个由构造器创建的对象，都有一个隐式引用(*proto*)链接到构造器的“prototype”属性值,即构造器的原型对象。原型对象可能有一个非空 (non-null) 隐式引用链接到它自己的原型，以此类推，这叫做 原型链 。
  + 当试图访问一个 JavaScript 实例的属性 / 方法时，它首先搜索这个实例本身；当发现实例没有定义对应的属性 / 方法时，它会转而去搜索实例的原型对象；如果原型对象中也搜索不到，它就去搜索原型对象的原型对象，这个搜索的轨迹，就叫做原型链。

```js
function People(name) {
  this.name = name;
}
People.prototype.eat = function () {
   console.log(`${this.name} eat something`)
}

//ES5寄生组合式实现继承
function Student(name,number) {
   // 先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。
   People.call(this,name)            // 借用构造函数, 第一次调用父类构造函数
   this.number = number
}

Student.prototype = Object.create(People.prototype)  // 使用 Object.create 内置函数，通过明确指定原型来创建一个新对象。
Student.prototype.constructor = Student;

Student.prototype.sayHi = function () {
   console.log(`姓名:${this.name},学号:${this.number}`)
}

const xialuo = new Student("夏洛",23)
console.log(xialuo.name)     //夏洛
console.log(xialuo.number)   //23
xialuo.sayHi(); //姓名:夏洛,学号:23
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200108144237185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ3MzExNA==,size_16,color_FFFFFF,t_70)

​	xialuo是通过Student new出来的，所以xialuo的__proto__指向Student的prototype。Student继承于	People，内部原理为Student.prototype的原型指向People.prototype，所以Student.prototype.__proto__指向People.prototype

### 38.  数组去重!!!!!!!!!!!!!!!!!!!!!!!!!!!

### 39.  垃圾回收机制

JavaScript 中的内存管理是自动执行的，而且是不可见的。我们创建基本类型、对象、函数……所有这些都需要内存。

当不再需要某样东西时会发生什么? JavaScript 引擎是如何发现并清理它?

[**可达性**](https://segmentfault.com/a/1190000018605776)

JavaScript具有自动垃圾收集机制,也就是说,执行环境(一般为浏览器)会负责管理代码执行过程中使用的内存.这种垃圾回收机制的原理很简单:找出那些不再使用的变量,然后释放他们所占用的内存.为此垃圾收集器会按照固定的时间间隔(或代码执行中预定的收集时间),周期性的执行这一操作.

浏览器实现这一机制通常有以下两种策略:

+ 标记清除(maker-and sweep)

  这是javascript中最常用的垃圾收集方式.当变量进入环境时(例如,在函数中声明一个变量)时,就将这个变量声明为"进入环境".从逻辑上讲,永远不能释放进入环境的变量所占的内存,因为只要执行流进入到相应的环境,就有可能用到它们,而当变量离开环境时,就将变量标记为"离开环境".

  垃圾收集器会为存储在内存中的所有变量都加上标记(当然,可以使用任何标记方式).当变量"离开环境"时,垃圾收集器就会为变量加上"销毁"标记.最后,垃圾收集器完成内存清理工作.销毁那些带有"销毁"标记的变量并回收它们所占用的内存空间.

  IE,Chrome,Firefox,  Opera和Safari都是使用这种策略(或类似的方式)来实现垃圾清除的,只不垃圾回收的时间间隔不同.

+ 引用计数(reference counting)

  另一种不太常用的垃圾回收机制叫做引用计数.引用计数的含意是跟踪每个变量被引用的次数.当声明一个变量并将一个引用类型值赋给该变量时,则这个值的引用次数就加1.如果同一个值又被赋予另外一个变量,则该值的引用次数加1.相反,如果包含对这个值引用的变量又取得了另外一个值,则这个值的引用次数减1.当这个值的引用次数变为0的时候,则说明没有办法再访问这个值了,因而就可以将其占用的空间回收回来.这样,当垃圾收集器下次再运行时,它就会释放那些引用次数为0的值所占用的内存空间了.

  虽然这种方式很简单,也很容易理解,但它存在一个非常的问题:循环引用.循环引用是指对象A包含对对象B的引用,而对象B又包含对对象A的引用.如下:

>  Function problem()
>
> {
>
> Var objectA=new Object();
>
> Var objectB=new Object();
>
> objectA.property=objectB;
>
> objectB.property=objectA;
>
> }

在标记清除的策略中,由于上而的函数执行完毕后,这两个对象都离开了作用域,因此这种相互引用不存在问题.但在引用计数的实现中,当函数执行完毕,objectA和objectB还将继续存在,因为它用的引用计数永远不会为0.假如这种重复引用的函数被调用多次,则会导致大量的内存无法回收.

基本上没有浏览器用这种回收机制,但是这种麻烦并没有得到终止.

我们知道,IE中有一部分对象并不是原生的javascript对象,例如,BOM和DOM中的对象就是使用C++以COM(Component object model 组件对象模型)对象的形式来实现的.而COM的垃圾回收机制采用的就是引用计数的策略.因此,即使IE的javascript引擎是用标记清除策略来实现的,但javascript访问的COM对象依然是基于引用计数策略.换句话说,只要在IE中涉及DOM对象,就会存在循环引用的问题.下面简单的例子,展示了使用DOM对象产生的循环引用问题:

> Var element=document.getElementById("some_element");
>
> Var myObject=new Object();
>
> Myobject.element=element;
>
> Element.object=myObject;

为了避免循环引用问题的发生,最好在不再使用它们的时候,手动最两个对象之间的互相引用断开.如下

> myObject.element=null;
>
> Element.object=null;

将变量的值设为null,就意味着切断变量与它此前引用的值之间的连接.当垃圾收集器下次运行时,就会删除这些值并回收它们所占用的内存.

### 40.  symbol特性

### 41.  可迭代接口怎么实现的

### 42.  ES6后，除了可迭代接口还出现了什么接口

### 43.  事件流event.target 和 event.currenttarget

### 44.1  js能表示的最大安全整数是多少？为什么？

### 44.2  浮点数在计算机内部怎么表示的

### 45.  call apply bind 区别

+ call、apply、bind都是改变this指向的方法
+ 当`call`方法执行的时候，内部处理了一些事情
  1.首先把要操作的函数中的this关键字变为`call`方法第一个传递的实参
  2.把`call`方法第二个及之后的实参获取到
  3.把要操作的函数执行，并且把第二个以后传递进来的实参传递给函数

```js
fn.call([this],[param]...)
```

+ apply：和call基本上一致，唯一区别在于传参方式，apply 传的是数组
+ bind：语法和call一模一样，区别在于立即执行还是等待执行

### 46.  进程，线程

### 47.  arguments相关内容

### 48.  变量提升

https://www.cnblogs.com/moqing/p/5588606.html

## Vue（ + http)

### 1.  Vue 2.0 Vue 3.0 区别

https://www.freesion.com/article/8237785084/

### 2.1  Vue生命周期

+ 首先new 一个Vue组件

+ 初始化事件和生命周期函数

+ + beforeCreate 准备创建props，data，methods，但是现在还不能用（可以进行loading事件）

+ 初始化props，data，methods

+ + created 已经创建props，data，methods，但是组件模板结构尚未生成（在这个阶段可以发起AJAX请求）

+ 接下来的几步就是根据数据和模板，在内存中编译生成HTML结构

  （1 . 是否有el , 若没有看是否有$mount(el), 

   	2.  是否有template.  有就编译template中的HTML，没有就编译el指向的HTML结构）

+ + beforeMount 将要把内存中编译好的HTML结构渲染到浏览器中

+ 用内存中生成的HTML结构替换el 指向的DOM结构

+ + mounted 已经把内存中生成的HTML结构渲染到浏览器中（可以发起**后端**请求，拿回数据）

+ 当数据发生变化时

+ + beforeUpdated 将要根据变化后最新的数据重新渲染模板结构

+ 根据变化后最新的数据重新渲染模板结构

+ + updated 完成了重新渲染模板结构

+ 要进行销毁时

+ + beforeDestory 即将销毁组件

+ 准备销毁数据侦听器，子组件，事件监听

+ + destoryed 已经完全销毁DOM结构

### 2.2 父子组件生命周期

- 执行顺序：

- - 父组件开始执行到beforeMount 然后开始子组件执行，最后是父组件mounted。
  - 如果有兄弟组件，父组件开始执行到beforeMount，然后兄弟组件依次执行到beforeMount，然后按照顺序执行mounted，最后执行父组件的mounted。

- 当子组件挂载完成后，父组件才会挂载。

- 当子组件完成挂载后，父组件会主动执行一次beforeUpdate/updated钩子函数（仅首次）

- 父子组件在data变化中是分别监控的，但是更新props中的数据是关联的。

- 销毁父组件时，先将子组件销毁后才会销毁父组件。

- 兄弟组件的初始化（mounted之前）是分开进行，挂载是从上到下依次进行

- 当没有数据关联时，兄弟组件之间的更新和销毁是互不关联的

- ***\*Vue 的父组件和子组件生命周期钩子执行顺序？\****

  核心答案：

  第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子。

  **渲染过程：**

  父组件挂载完成一定是等子组件都挂载完成后，才算是父组件挂载完，所以父组件的mounted在子组件mouted之后

  父beforeCreate -> 父created -> 父beforeMount -> 子beforeCreate -> 子created -> 子beforeMount -> 子mounted -> 父mounted

  **子组件更新过程：**

  影响到父组件：父beforeUpdate -> 子beforeUpdate->子updated -> 父updted

  不影响父组件：子beforeUpdate -> 子updated

  **父组件更新过程：**

  影响到子组件：父beforeUpdate -> 子beforeUpdate->子updated -> 父updted

  不影响子组件：父beforeUpdate -> 父updated

  **销毁过程：**

  父beforeDestroy -> 子beforeDestroy -> 子destroyed -> 父destroyed

  重要：父组件等待子组件完成后，才会执行自己对应完成的钩子。

### 3.  watch computed methods区别

+ 三者区别
  + watch
    + 一个对象，键是需要观察的表达式，值是对应回调函数。       
    + 主要用来监听某些特定数据的变化，一个数据影响多个数据。      
    + 可以看作是computed和methods的结合体。
  + computed
    + 属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。          
    + 计算属性，一个数据受多个数据影响。
  + methods
    + 方法表示一个具体的操作，主要是书写业务逻辑。
+ watch 用途
  + watch属性可以来 监听data属性中的数据变化。
  + watch属性还可以来监听function中使用参数来获取新值(newValue)和旧值(oldValue)。
  + watch属性还可以用来监听路由router的变化，只是这里的监听元素是固定的。
+ computed 用途
  + computed也可以监听属性的变化，只是它会根据他的依赖属性生成一个属性，从而影响这个属性的变化。

### 4.  v-if v-for 区别

+ 当它们处于同一节点，`v-for` 的优先级比 `v-if` 更高，这意味着 `v-if` 将分别重复运行于每个 `v-for` 循环中。（Vue2.0，Vue3.0相反）

### 4.2 v-if v-show 区别

+ `v-if` 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。是通过控制DOM节点存在来控制元素显隐。

+ `v-if` 也是**惰性的**：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。

+ 相比之下，`v-show` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。

+ 一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。

### 5.1  Vue父子组件之间如何传值

+ **父组件向子组件传值**

  + 父组件向子组件共享数据需要使用**自定义属性**：

  + ```vue
    // 父组件
    <Son :msg="message" :user="userinfo"></son>
    
    data() {
        return {
            message: 'hello vue.js',
            userinfo: { name:'zs', age: 20 }
        }
    }
    ```

  + ```vue
    // 子组件
    <template>
        <div>
        	<h5>Son组件</h5>
    		<p>父组件传递过来的 msg 值是：{{ msg }}</p>
            <p>父组件传递过来的 user 值是：{{ user }}</p>
        </div>
    </template>
    
    props: ['msg', 'user']
    ```

+ **子组件向父组件传值**

  + 子组件向父组件共享数据使用**自定义事件**：

  + ```vue
    // 子组件
    export default {
    	data() {
    		return { count: 0 }
    	},
    	methods: {
    		add() {
    			this.count += 1
    			// 修改数据时，通过 $emit() 触发自定义事件
    			this.$emit('numchange', this.count)
    		}
    	}
    }
    ```

  + ```vue
    <Son @numchange="getNewCount"></Son>
    
    export default {
    	data() {
    		return { countFromSon: 0 }
    	},
    	methods: {
    		getNumCount(val) {
    			this.countFromSon = val
    		}
    	}
    }
    ```

    

### 5.2  兄弟组件的通信方式

+ 在vue2.x中，兄弟组件之间数据共享的方案是EventBus：

+ ```vue
  // 兄弟组件A（数据发送方）
  import bus from './eventBus.js'
  
  export default {
  	data() {
  		return {
  			msg: 'hello vue.js'
  		}
  	},
  	methods: {
  		sendMsg() {
  			bus.$emit('share', this.msg)
  		}
  	}
  }
  ```

+ ```vue
  // eventBus.js
  import Vue from 'vue'
  
  // 向外共享 Vue 的实例对象
  export default new Vue()
  ```

+ ```vue
  // 兄弟组件C（数据接收方）
  import bus from './eventBus.js'
  
  export default {
  	data() {
  		return {
  			msgFromLeft: ''
  		}
  	},
  	created() {
  		bus.$on('share', val => {
  			this.msgFromLeft =val
  		})
  	}
  }
  ```

### 6.1  讲讲单页面应用和多页面应用

+ 引用百度百科：



![img](https:////upload-images.jianshu.io/upload_images/14591403-1169e29a4ebc5d0a.png?imageMogr2/auto-orient/strip|imageView2/2/w/832/format/webp)



**单页面应用的优缺点：**

+ 优点：
  1、用户操作体验好，用户不用刷新页面，整个交互过程都是通过Ajax来操作。
  2、适合前后端分离开发，服务端提供http接口，前端请求http接口获取数据，使用JS进行客户端渲染。

+ 缺点：
  1、首页加载慢
        单页面应用会将js、 css打包成一个文件，在加载页面显示的时候加载打包文件，如果打包文件较大或者网速慢则用户体验不好
  2、SEO不友好
        SEO（Search Engine Optimization）为搜索引擎优化。它是一种利用搜索引擎的搜索规则来提高网站在搜索引擎排名的方法。目前各家搜索引擎对JS支持不好，所以使用单页面应用将大大减少搜索引擎对网站的收录。

![img](https:////upload-images.jianshu.io/upload_images/14591403-4b68ae4490da72c4.png?imageMogr2/auto-orient/strip|imageView2/2/w/708/format/webp)



**为什么页面切换快？**

+ 页面每次切换跳转时，并不需要做`html`文件的请求，这样就节约了很多`http`发送时延，我们在切换页面的时候速度很快。

+ 缺点：首屏时间慢，SEO差

+ 单页应用的首屏时间慢，首屏时需要请求一次`html`，同时还要发送一次`js`请求，两次请求回来了，首屏才会展示出来。相对于多页应用，首屏时间慢。
  SEO效果差，因为搜索引擎只认识`html`里的内容，不认识`js`的内容，而单页应用的内容都是靠`js`渲染生成出来的，搜索引擎不识别这部分内容，也就不会给一个好的排名，会导致单页应用做出来的网页在百度和谷歌上的排名差。

##### 有这些缺点，为什么还要使用Vue呢？

+ `Vue`还提供了一些其它的技术来解决这些缺点，比如说服务器端渲染技术([我是SSR](https://cn.vuejs.org/v2/guide/ssr.html))，通过这些技术可以完美解决这些缺点，解决完这些问题，实际上单页面应用对于前端来说是非常完美的页面开发解决方案。

| mm                         | 多页应用模式MPA                                          | 单页应用模式SPA                                              |
| -------------------------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| 应用构成                   | 由多个完整页面构成                                       | 一个外壳页面和多个页面片段构成                               |
| 跳转方式                   | 页面之间的跳转是从一个页面跳转到另一个页面               | 页面片段之间的跳转是把一个页面片段删除或隐藏，加载另一个页面片段并显示出来。这是片段之间的模拟跳转，并没有开壳页面 |
| 跳转后公共资源是否重新加载 | 是                                                       | 否                                                           |
| URL模式                    | `http://xxx/page1.html 和 http://xxx/page2.html`         | `http://xxx/shell.html#page1 和 http://xxx/shell.html#page2` |
| 用户体验                   | 页面间切换加载慢，不流畅，用户体验差，特别是在移动设备上 | 页面片段间的切换快，用户体验好，包括在移动设备上             |
| 能否实现转场动画           | 无法实现                                                 | 容易实现（手机`app`动效）                                    |
| 页面间传递数据             | 依赖`URL、cookie`或者`localstorage`，实现麻烦            | 因为在一个页面内，页面间传递数据很容易实现(这里是我补充，父子之间传值，或`vuex`或`storage`之类) |
| 搜索引擎优化（SEO）        | 可以直接做                                               | 需要单独方案做，有点麻烦                                     |
| 特别适用的范围             | 需要对搜索引擎友好的网站                                 | 对体验要求高的应用，特别是移动应用                           |
| 搜索引擎优化（SEO）        | 可以直接做                                               | 需要单独方案做，有点麻烦                                     |
| 开发难度                   | 低一些，框架选择容易                                     | 高一些，需要专门的框架来降低这种模式的开发难度               |



### 6.2  单页面性能优化

+ **1） 加载优化**
      在SPA中，通常一开始就会加载所有必需的代码（HTML，JavaScript和CSS），有时候考虑到首屏加载太慢会按需加载，按需加载就是按照当前呈现的不同页面加载不同的文件，而不是最开始就把所有文件都加载出来，从而避免首屏加载很慢。
      当首屏加载完毕后，设备&网络处于空闲状态，可以对其他路由组件进行预加载，以便提升页面切换性能。
      根据路由拆分减少初始加载体积,利用异步加载方式，在路由注册时提供异步拉取组件的方法，仅在需要进入对应路由时，对应组件才会被加载进来。 

- 初次加载的速度

​        单页应用的第一页加载会比基于服务器的应用慢。这是因为首次加载必须先拿到框架和应用程序的代码，再在浏览器中呈现所需的视图。基于服务器的应用程序只需将所需的HTML推送到浏览器，从而减少了延迟和下载用时。

- 加快页面加载速度

​         有一些方法可以加快单页应用的初次加载速度，比如采用多项缓存措施、需要时再加载某些模块（懒加载）。

- 页面生命周期

​        单页应用在初始页面加载时被完全加载，然后页面区域被替换或更新为按需从服务器加载的新页面片段。为避免过度下载未使用的功能，单页应用通常会逐渐下载更多内容，如所需要的功能、页面的一小块，或者完整的一页。

![img](https://img-blog.csdnimg.cn/20190109221137217.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncGIxMjM=,size_16,color_FFFFFF,t_70)

**2)   SEO优化**
        由于我们在处理单页应用的时候页面是不刷新的，所以会导致我们的网页记录和内容很难被搜索引擎抓取到。搜索引擎抓取页面首先要遵循http协议，可是#不是协议内的内容。而实际上也是这样，我们没有见过搜索引擎的搜索结果中，哪一条记录可以快速定位到网页内的某个位置的。解决的方法是用 #!号代替#号，因为谷歌会抓取带有#!的URL。（Google规定，如果你希望Ajax生成的内容被浏览引擎读取，那么URL中可以使用"#!"(这种URL在一般页面一般不会产生定位效果)），这样我们可以解决ajax的不被搜索引擎抓取的问题。在vueJs里面，我们可以看到作者就是这样做的。
**3)   前进后退功能优化**
        配置好路由信息，通过记录浏览过的历史路由信息，可以很好的记录或历史查看过的界面，也可以独立写个足迹功能实现。

### 7.   Vue数据流（待补充）

+ vue 遵循了典型的**单向数据流**的原则，即数据总是由父组件传递到子组件，子组件在其内部可以有自己维护的数据，但它无权修改父组件传递给它的数据，当开发者尝试这样做的时候，vue 将会报错。这样做的好处是，防止多个子组件都尝试修改父组件状态时，让这一行为变得难以追溯。vue 中具体实现方式如下：

[![img](https://files.jb51.net/file_images/article/201707/2017726160315484.png?201762616327)](https://files.jb51.net/file_images/article/201707/2017726160315484.png?201762616327)

+ 父组件通过绑定 props 的方式，将数据传递给子组件，但是子组件自己并没有权利修改这些数据，如果要修改，只能把修改这一个行为通过 event 的方式报告给父组件，由父组件本身决定改如何处理数据。
+ **数据流向分析**
  + （1）我们在父组件中定义了一个数据叫 counter；
  + （2）调用组件的时候，通过 :counter="counter" 的方式，将父组件的 counter 以 prop 的方式传递到子组件中；
  + （3）子组件读取到 counter，并将其展示在模板中；
  + （4）用户点击按钮，counter 需要增加；
  + （5）子组件监听到这个事件，但它并不直接修改 counter，而是通过 this.$emit('inc'); 以自定义事件的形式，将需要增加的这一个事件报告给父组件；
  + （6）父组件中，由于通过执行过 @inc="increase" ，能够监听到子组件报告过来的事件，并在自己的 increase 方法中，实现 counter 的增加；
  + （7）父组件里的数据更新了，子组件里的数据也将自动更新，同时也将更新界面内容，这一过程由框架自动完成。

### 8.  Vue双向数据绑定

https://www.cnblogs.com/canfoo/p/6891868.html

### 9.  webpack相关(如何优化)--(待补充)

https://webpack.docschina.org/concepts/entry-points/

### 10. 打包资源优化（待补充）

+ 对于打包资源优化的总体原则，在于尽可能的**减少或者延迟模块的引用**。主要遵循以下三点：
  + **减小打包的整体体积**
  + **Code Splitting** : **按需加载，优化页面首次加载体积**。如根据路由按需加载，根据是否可见按需加载
  + **Bundle Splitting** ：**分包**，根据模块更改频率分层次打包，充分利用缓存

+ **减小打包的整体体积**

  + 第一种方法是减小打包的整体体积。减小打包的总体积有多种方式，这往往也是打包资源优化的着力点，一方面操作性高易于实践，另一方面有具体数据支撑易于写PPT来晋升。我从网站性能优化的实践角度，来分为以下几个方面：

  + **代码压缩**

    ​	代码压缩可以非常可观地减小资源打包体积，但是它的可操作性空间过小。可操作性低的意思是这一项不太容易出现在晋级评审的PPT上，如同 CDN 在网站性能优化的重要程度一样，重要但不归你做(或者傻瓜式配置)。

    ​	它良好的模块化，以致于 webpack 就自作主张在生产环境中默认把这件事给做了。

    ​	那它是如何压缩代码的？最典型的两种方法就是空白符替换以及缩短变量名。

  + **移除不必要的模块**

    ​	eslint 的用武之地来了，它除了统一团队的代码风格以外，也用来提高团队的代码质量以及性能。

  + **选择可替代的体积较小的模块**

  + **按需引入模块**

    ​	当你面对一个大型模块时，可能你并不会使用到它的所有的功能，你只需要按照你的需求引入模块就可以了。

+ **Code Splitting: 按需加载，优化页面首次加载体积**

  + 通过 `Code Splitting` 可以只加载当前所需要的核心资源：
    + 如果你处在首页，并且首页中有占用资源过重的图表，需要对图表懒加载，否则它会大幅拖垮应用的首次渲染，加大白屏时间
    + 如果你处在首页，你无需加载当前不可见屏幕下方的复杂组件
    + 如果你处在页面 A，你没有必要加载页面 B 的资源
  + 他们实现起来均需要额外编写代码，所以可操作性中等，但是好在它能够带来极大的益处，投资回报率较高，操作起来也极为简单，接下来就属于体力活了：
    + 使用 `import()` 动态加载模块
    + 使用 `React.lazy()` 动态加载组件
    + 使用 `lodable-component` 动态加载路由，组件或者模块

+ **Bundle Splitting：分包**

  + ​	除了资源体积上的优化，另一个大的优化就是缓存。单页应用有一个最好的方面，就是所有资源都是带有指纹信息的，这意味着所有的资源都是能够设置永久缓存的。

    ​	但仅仅如此了吗？

    ​	如果你所有的 js 资源都打包成一个文件，它确实有永久缓存的优势。但是当有一行文件进行修改时，这一个大包的指纹信息发生改变，永久缓存失效。

    ​	所以我们现在需要做到的是：当修改文件后，造成最小范围的缓存失效，这样便能够更充分的利用缓存，减小宽带，减小服务器费用。一个好消息是 webpack 等打包工具虽然在 optimization 上内置了很多性能优化，但它不会帮你做这件事，它并不知道你有哪些模块，以及这些模块的重要紧急程度，你终于可以大展拳脚了。

### 11.  Vue 技术栈



### 12.  

### 13.  promise有哪些方法，all  race 方法以及应用场景

+ **回调地狱**

  + 涉及到多层函数的相互嵌套，就会形成回调地狱
  + 回调地狱的特点：
    + 代码耦合性太强，难以维护
    + 大量冗余代码相互嵌套，代码的可读性变差

  ```js
  setTimeout( () => {
      console.log("延时 1 秒后输出")
      
      setTimeout( () => {
          console.log("延时 2 秒输出")
          
          setTimeout( () => {
              console.log("延时 3 秒输出")
          }, 3000)
      }, 2000)
  }, 1000)
  ```

  + 为了解决回调地狱的问题，ES6新增promise的概念

+ **promise基本概念**

  + promise 是一个构造函数
    + 我们可以创建Promise的实例 **const p = new Promise()**
    + new出来的Promise实例对象，**是一个异步操作**
  + promise.prototype 上包含一个 .then() 方法
    + 每一次 new Promise() 构造函数得到的实例对象，都可以通过原型链的方式访问到 .then() 方法，例如 **p.then()**
  +  .then() 方法用来预先指定成功和失败的回调函数
    + p.then( **成功的回调函数，失败的回调函数**)
    + p,then( result => {} , error => {} )
    + 成功的回调函数是必选的，失败的回调函数是可选的
    + 成功失败的回调函数，可以在new Promise的function的形参中进行接收（resolve，reject）

+ **promise.then()**

  +  .then() 方法用来预先指定成功和失败的回调函数
  + .then()返回一个新的Promise实例，所以它可以链式调用
  + 成功失败的回调函数，可以在new Promise的function的形参中进行接收（resolve，reject）

+ **promise.catch()**

  + 用于指定发生错误时的回调函数
  + then方法指定的回调函数如果运行时抛出错误，会被catch方法捕获
  + 如果不希望前面的错误导致后面的 .then() 无法正常执行，可以将 .catch 的调用提前

+ **promise.all()**

  + promise.all() 会发起并行的Promise异步操作，**等所有异步操作全部结束后**才会执行下一步的操作 

  + 接收一个数组作为参数
    + 数组里可以是Promise对象，也可以是别的值，只有Promise会等待状态改变
    + 当所有的子Promise都完成，该Promise完成，返回值是全部值得数组
    + 有任何一个失败，该Promise失败，返回值是第一个失败的子Promise结果

```js
        //切菜
    function cutUp(){
        console.log('开始切菜。');
        var p = new Promise(function(resolve, reject){        //做一些异步操作
            setTimeout(function(){
                console.log('切菜完毕！');
                resolve('切好的菜');
            }, 1000);
        });
        return p;
    }

    //烧水
    function boil(){
        console.log('开始烧水。');
        var p = new Promise(function(resolve, reject){        //做一些异步操作
            setTimeout(function(){
                console.log('烧水完毕！');
                resolve('烧好的水');
            }, 1000);
        });
        return p;
    }

    Promise.all([cutUp(), boil()])
        .then((result) => {
            console.log('准备工作完毕');
            console.log(result);
        })
    console.log(12); 
```

```js
开始切菜。
开始烧水。
12
切菜完毕！
烧水完毕！
准备工作完毕
['切好的菜', '烧好的水']
```

+ **promise.race()**
  + promise.race()会发起并行的Promise异步操作,**只要有一个异步操作完成，就立即执行下一步 .then 操作**，其余和promise.all() 类似

```js
    let p1 = new Promise(resolve => {
        setTimeout(() => {
            resolve('I\`m p1 ')
        }, 1000)
    });
    let p2 = new Promise(resolve => {
        setTimeout(() => {
            resolve('I\`m p2 ')
        }, 2000)
    });
    Promise.race([p1, p2])
        .then(value => {
            console.log(value)
        })
    console.log(12);
```

```js
12
I`m p1 
```

+ **async / await**
  + 用来简化Promise异步操作，解决了链式调用的代码冗余，阅读性差等缺点
  + async声明的函数的返回本质上是一个Promise
  + 如果在function中使用了await，则function必须被async修饰
  + 在async方法中，第一个await之前的代码会同步执行，await之后的代码会异步执行

### 14.  cookie 和 webstorage区别

+ 特性
  + cookie 由服务器生成，存储在浏览器的，可以设置失效时间
  + localstorage 除非主动删除，否则即使浏览器关闭内容也不会清除
  + sessionstorage 浏览器关闭后数据会自动删除
+ 大小
  + cookie 可以存储大小约为4KB 
  + webstorage 可以存储大小为5MB左右
+ 与服务器
  + cookie 由服务器生成，发送给服务器，会在服务器下一次请求时被携带
  + webstorage 与服务器没有联系
+ 接口
  + cookie 接口原生的不友好，需要程序员自己封装
  + webstorage 原生接口就可以

### 15.  cookie怎么保存到本地的，cookie怎么实现跨域



### 16.  跨域相关问题

https://www.jianshu.com/p/9f0ffb551309

https://segmentfault.com/a/1190000007326671

### 17.  常见状态码

+ 200： OK
+ 301：永久重定向
+ 302：临时重定向
+ 303：临时重定向，可以使用get获取到新的URL
+ 304：上次请求的网页未修改（可以进行强制刷新）
+ 401：未授权
+ 403：禁止访问
+ 404：找不到资源

### 18.  v-for 中 key 的作用，没有 key 会怎么样

+ 在写v-for的时候必须要加key，作为唯一标识，可以提高渲染性能，防止数据混乱。

### 19.  观察者模式三个类



### 20.1 token session的区别



### 20.2 cookie session 区别

https://www.zhihu.com/question/353373715/answer/878707077

### 21.1  TCP三次握手，为什么有三次握手

https://www.zhihu.com/question/271701044

### 21.2  四次挥手

### 22.  https 用了对称加密和非对称加密吗？为什么使用对称加密？



### 23.  动态数组在尾部插入一个元素，时间复杂度，空间复杂度



### 24.  数组和链表的区别



### 25.  节流 防抖（防抖中用到了一个很重要的思想）

[节流（throttle）与防抖（debounce）](https://www.vigor666.com/posts/e1c9a583.html)

+ **背景**

  + 在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。
  + 通常这种情况下我们怎么去解决的呢？一般来讲，防抖和节流是比较好的解决方案。

+ **防抖**

  + **所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。**

  + 防抖函数分为非立即执行版和立即执行版。

  + **非立即执行版：**

    + ```js
      function debounce(func, wait) {
          let timeout;
          return function () {
              let context = this;
              let args = arguments;
      
              if (timeout) clearTimeout(timeout);
              
              timeout = setTimeout(() => {
                  func.apply(context, args)
              }, wait);
          }
      }
      ```

    + 非立即执行版的意思是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。

      我们依旧使用上述绑定 mousemove 事件的例子，通过上面的防抖函数，我们可以这么使用:

      ```js
      content.onmousemove = debounce(count,1000);
      ```

      效果如下：

      ![img](https://upload-images.jianshu.io/upload_images/4842858-1f6389b9dd9e5ef9.gif?imageMogr2/auto-orient/strip|imageView2/2/w/1134/format/webp)

      可以看到，在触发事件后函数 1 秒后才执行，而如果我在触发事件后的 1 秒内又触发了事件，则会重新计算函数执行时间。

  + **立即执行版**

    + ```js
      function debounce(func,wait) {
          let timeout;
          return function () {
              let context = this;
              let args = arguments;
      
              if (timeout) clearTimeout(timeout);
      
              let callNow = !timeout;
              timeout = setTimeout(() => {
                  timeout = null;
              }, wait)
      
              if (callNow) func.apply(context, args)
          }
      }
      ```

      立即执行版的意思是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。

      效果如下：

      ![img](https://upload-images.jianshu.io/upload_images/4842858-067785c056f182d8.gif?imageMogr2/auto-orient/strip|imageView2/2/w/1140/format/webp)

      在开发过程中，我们需要根据不同的场景来决定我们需要使用哪一个版本的防抖函数，一般来讲上述的防抖函数都能满足大部分的场景需求。但我们也可以将非立即执行版和立即执行版的防抖函数结合起来，实现最终的双剑合璧版的防抖函数。

      ```js
      /**
       * @desc 函数防抖
       * @param func 函数
       * @param wait 延迟执行毫秒数
       * @param immediate true 表立即执行，false 表非立即执行
       */
      function debounce(func,wait,immediate) {
          let timeout;
      
          return function () {
              let context = this;
              let args = arguments;
      
              if (timeout) clearTimeout(timeout);
              if (immediate) {
                  var callNow = !timeout;
                  timeout = setTimeout(() => {
                      timeout = null;
                  }, wait)
                  if (callNow) func.apply(context, args)
              }
              else {
                  timeout = setTimeout(function(){
                      func.apply(context, args)
                  }, wait);
              }
          }
      }
      ```

+ **节流**

  + **所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。**

  + 节流会稀释函数的执行频率。

    对于节流，一般有两种方式可以实现，分别是时间戳版和定时器版

  + **时间戳版：**

    ```js
    function throttle(func, wait) {
        let previous = 0;
        return function() {
            let now = Date.now();
            let context = this;
            let args = arguments;
            if (now - previous > wait) {
                func.apply(context, args);
                previous = now;
            }
        }
    }
    ```

    使用方式如下:

    ```js
    content.onmousemove = throttle(count,1000);
    ```

    效果如下：

    ![img](https://upload-images.jianshu.io/upload_images/4842858-80423b8898a27732.gif?imageMogr2/auto-orient/strip|imageView2/2/w/1140/format/webp)

    可以看到，在持续触发事件的过程中，函数会立即执行，并且每 1s 执行一次。

  + **定时器版:**

    ```js
    function throttle(func, wait) {
        let timeout;
        return function() {
            let context = this;
            let args = arguments;
            if (!timeout) {
                timeout = setTimeout(() => {
                    timeout = null;
                    func.apply(context, args)
                }, wait)
            }
    
        }
    }
    ```

    效果如下：

    ![img](https://upload-images.jianshu.io/upload_images/4842858-bf2ed4c8ed4f0ec0.gif?imageMogr2/auto-orient/strip|imageView2/2/w/1136/format/webp)

    可以看到，在持续触发事件的过程中，函数不会立即执行，并且每 1s 执行一次，在停止触发事件后，函数还会再执行一次。

    我们应该可以很容易的发现，其实时间戳版和定时器版的节流函数的区别就是，时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。

    同样地，我们也可以将时间戳版和定时器版的节流函数结合起来，实现双剑合璧版的节流函数。

    ```js
    /**
     * @desc 函数节流
     * @param func 函数
     * @param wait 延迟执行毫秒数
     * @param type 1 表时间戳版，2 表定时器版
     */
    function throttle(func, wait ,type) {
        if(type===1){
            let previous = 0;
        }else if(type===2){
            let timeout;
        }
        return function() {
            let context = this;
            let args = arguments;
            if(type===1){
                let now = Date.now();
    
                if (now - previous > wait) {
                    func.apply(context, args);
                    previous = now;
                }
            }else if(type===2){
                if (!timeout) {
                    timeout = setTimeout(() => {
                        timeout = null;
                        func.apply(context, args)
                    }, wait)
                }
            }
        }
    }
    ```

    

### 26.  vue  diff算法（以及虚拟DOM变化及处理）



### 27.  vue响应式原理



### 28.  Vue源码解析


### 29.  单例模式



### 30.1  浏览器缓存（什么时候用）（http缓存）

### 30.2 如果后台数据只有一个字母a，先将他删除，再添加一个字母a, 会命中缓存吗？



### 31.  Vue怎么更新组件



### 32.  



### 33.  浏览器请求方式



### 34.  Ajax怎么实现异步通信



### 35.  插槽的使用



### 36.1 如何实现页面跳转，路由跳转怎么实现



### 36.2 路由原理

https://www.cnblogs.com/gaosirs/p/10606266.html

### 37.  vue 和 js 的关系



### 38.  vue 的原理或特性



### 39.  vue什么组件能实现增删改



### 40.  前端安全  xsrf怎么防御



### 41.  http组成部分



### 42.  响应头部



### 43.  数据结hash



### 44.  vue Router



### 45.  网络协议



### 46.  socket了解吗



### 47.  vue的特点 优点

http://c.biancheng.net/view/6714.html

### 48.  vuex的使用场景(组成等相关)



### 49.  Ajax实现过程，和promise区别



### 50.  http https 区别，http 如何升级到 https



### 51.  前端各种性能提升



### 52. has history 的区别



### 53. TCP UDP 区别

+ TCP和UDP区别

|            | TCP            | UDP        |
| ---------- | -------------- | ---------- |
| 是否连接   | 面向连接       | 面向非连接 |
| 传输可靠性 | 可靠的         | 不可靠的   |
| 应用场合   | 传输大量的数据 | 少量数据   |
| 速度       | 慢             | 快         |

 

+ OSI 和 TCP/IP 模型在传输层定义两种传输协议：TCP（或传输控制协议）和 UDP（或用户数据报协议）。

+ UDP
  + UDP 与 TCP 的主要区别在于 UDP 不一定提供可靠的数据传输。事实上，该协议不能保证数据准确无误地到达目的地。UDP 在许多方面非常有效。当某个程序的目标是尽快地传输尽可能多的信息时（其中任意给定数据的重要性相对较低），可使用 UDP。ICQ 短消息使用 UDP 协议发送消息。许多程序将使用单独的TCP连接和单独的UDP连接。重要的状态信息随可靠的TCP连接发送，而主数据流通过UDP发送。

+ TCP
  + TCP的目的是提供可靠的数据传输，并在相互进行通信的设备或服务之间保持一个虚拟连接。TCP在数据包接收无序、丢失或在交付期间被破坏时，负责数据恢复。它通过为其发送的每个数据包提供一个序号来完成此恢复。记住，较低的网络层会将每个数据包视为一个独立的单元，因此，数据包可以沿完全不同的路径发送，即使它们都是同一消息的组成部分。这种路由与网络层处理分段和重新组装数据包的方式非常相似，只是级别更高而已。
  + 为确保正确地接收数据，TCP要求在目标计算机成功收到数据时发回一个确认（即 ACK）。如果在某个时限内未收到相应的 ACK，将重新传送数据包。如果网络拥塞，这种重新传送将导致发送的数据包重复。但是，接收计算机可使用数据包的序号来确定它是否为重复数据包，并在必要时丢弃它。

+ TCP与UDP的选择
  + 如果比较UDP包和TCP包的结构，很明显UDP包不具备TCP包复杂的可靠性与控制机制。与TCP协议相同，UDP的源端口数和目的端口数也都支持一台主机上的多个应用。一个16位的UDP包包含了一个字节长的头部和数据的长度，校验码域使其可以进行整体校验。（许多应用只支持UDP，如：多媒体数据流，不产生任何额外的数据，即使知道有破坏的包也不进行重发。）
  + 很明显，当数据传输的性能必须让位于数据传输的完整性、可控制性和可靠性时，TCP协议是当然的选择。当强调传输性能而不是传输的完整性时，如：音频和多媒体应用，UDP是最好的选择。在数据传输时间很短，以至于此前的连接过程成为整个流量主体的情况下，UDP也是一个好的选择，如：DNS交换。把SNMP建立在UDP上的部分原因是设计者认为当发生网络阻塞时，UDP较低的开销使其有更好的机会去传送管理数据。TCP丰富的功能有时会导致不可预料的性能低下，但是我们相信在不远的将来，TCP可靠的点对点连接将会用于绝大多数的网络应用。

+ TCP协议和UDP协议特性区别总结：
  + 1. TCP协议在传送数据段的时候要给段标号；UDP协议不
    2. TCP协议可靠；UDP协议不可靠
    3. TCP协议是面向连接；UDP协议采用无连接
    4. TCP协议负载较高，采用虚电路；UDP采用无连接
    5. TCP协议的发送方要确认接收方是否收到数据段（3次握手协议）
    6. TCP协议采用窗口技术和流控制

### 54.  封装组件相关

https://blog.csdn.net/tangxiujiang/article/details/79620542



### 55.1  熟悉哪些设计模式，在哪里用到了vue的设计模式（待补充）

+ **设计模式的定义**是：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。通俗一点说，设计模式是在某种场合下对某个问题的一种解决方案。

  ​	设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案，他不是一个死的机制，他是一种思想，一种写代码的形式。每种语言对于各种设计模式都有他们自己的实现方式，对于某些设计模式来说，可能在某些语言下并不适用，比如工厂方法模式对于javascript。模式应该用在正确的地方。而哪些才算正确的地方，只有在我们深刻理解了模式的意图之后，再结合项目的实际场景才会知道

### 55.2  工厂模式的应用场景

### 55.3  发布订阅者模式和观察者模式的区别

+ **观察者模式**

  ​	观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新。观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯。

  ​	观察者模式有一个别名叫“发布-订阅模式”，或者说是“订阅-发布模式”，订阅者和订阅目标是联系在一起的，当订阅目标发生改变时，逐个通知订阅者。我们可以用报纸期刊的订阅来形象的说明，当你订阅了一份报纸，每天都会有一份最新的报纸送到你手上，有多少人订阅报纸，报社就会发多少份报纸，报社和订报纸的客户就是上面文章开头所说的“一对多”的依赖关系。

+ **发布订阅模式**

  ​	其实24种基本的设计模式中并没有发布订阅模式，上面也说了，他只是观察者模式的一个别称。

  ​	但是经过时间的沉淀，似乎他已经强大了起来，已经独立于观察者模式，成为另外一种不同的设计模式。

  ​	在现在的发布订阅模式中，称为发布者的消息发送者不会将消息直接发送给订阅者，这意味着发布者和订阅者不知道彼此的存在。在发布者和订阅者之间存在第三个组件，称为消息代理或调度中心或中间件，它维持着发布者和订阅者之间的联系，过滤所有发布者传入的消息并相应地分发它们给订阅者。

  ​	举一个例子，你在微博上关注了A，同时其他很多人也关注了A，那么当A发布动态的时候，微博就会为你们推送这条动态。A就是发布者，你是订阅者，微博就是调度中心，你和A是没有直接的消息往来的，全是通过微博来协调的（你的关注，A的发布动态）。

+ **发布订阅者模式和观察者模式的区别**

  我们先来看下这两个模式的实现结构：

  ![模式结构](https://img-blog.csdnimg.cn/20190329182209470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmODcyOTE0MzM0,size_16,color_FFFFFF,t_70)

  **观察者模式**： 观察者（Observer）直接订阅（Subscribe）主题（Subject），而当主题被激活的时候，会触发（Fire Event）观察者里的事件。

  **发布订阅模式**： 订阅者（Subscriber）把自己想订阅的事件注册（Subscribe）到调度中心（Topic），当发布者（Publisher）发布该事件（Publish topic）到调度中心，也就是该事件触发时，由调度中心统一调度（Fire Event）订阅者注册到调度中心的处理代码。

  

  观察者模式和发布订阅模式**最大的区别**就是**发布订阅模式有个事件调度中心**。

  ​	**观察者模式**由具体目标调度，每个被订阅的目标里面都需要有对观察者的处理，这种处理方式比较直接粗暴，但是会造成代码的冗余。

  ​	而**发布订阅模式**中统一由调度中心进行处理，订阅者和发布者互不干扰，消除了发布者和订阅者之间的依赖。这样一方面实现了解耦，还有就是可以实现更细粒度的一些控制。比如发布者发布了很多消息，但是不想所有的订阅者都接收到，就可以在调度中心做一些处理，类似于权限控制之类的。还可以做一些节流操作。

### 56.  如果浏览器不支持 object.definepoperty 如何兼容

### 57.  Ajax 相关内容

https://blog.csdn.net/chenjuan1993/article/details/81626487

### 58.  axios 请求方式的底层

### 59.  fetch 了解吗?浏览器如果不支持 fetch 要怎么用 fetch

### 60.  从输入 url 到页面渲染过程

+ **第一步：浏览器输入域名**

+ **第二步：浏览器查找域名的IP地址**

  + **浏览器会把输入的域名解析成对应的IP**，其过程如下：
    + 1  **查找浏览器缓存**：因为浏览器一般会缓存DNS记录一段时间，不同浏览器的时间可能不一样，一般2-30分钟不等，浏览器去查找这些缓存，如果有缓存，直接返回IP，否则下一步。
    + 2  **查找系统缓存**：浏览器缓存中找不到IP之后，浏览器会进行系统调用（windows中是gethostbyname），查找本机的hosts文件，如果找到，直接返回IP，否则下一步。
    + 3  **查找路由器缓存**：如果1,2步都查询无果，则需要借助网络，路由器一般都有自己的DNS缓存，将前面的请求发给路由器，查找ISP 服务商缓存 DNS的服务器，如果查找到IP则直接返回，没有的话继续查找。
    + 4  **递归查询**：如果以上步骤还找不到，则ISP的DNS服务器就会进行递归查询，所谓递归查询就是如果主机所询问的本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其他根域名服务器继续发出查询请求报文，而不是让该主机自己进行下一步查询。（本地域名服务器地址是通过DHPC协议获取地址，DHPC是负责分配IP地址的）
    + 5  **迭代查询**：本地域名服务器采用迭代查询，它先向一个根域名服务器查询。本地域名服务器向根域名服务器的查询一般都是采用迭代查询。所谓迭代查询就是当根域名服务器收到本地域名服务器发出的查询请求报文后，要么告诉本地域名服务器下一步应该查询哪一个域名服务器，然后本地域名服务器自己进行后续的查询。（而不是替代本地域名服务器进行后续查询）。
    + 本例子中：根域名服务器告诉本地域名服务器，下一次应查询的顶级域名服务器dns.net的IP地址。本地域名服务器向顶级域名服务器dns.net进行查询。顶级域名服务器dns.net告诉本地域名服务器，下一次应查询的权限域名服务器dns.csdn.net的IP地址。本地域名服务器向权限域名服务器dns.csdn.net进行查询。权限域名服务器dns.csdn.net告诉本地域名服务器，所查询的主机www.csdn.net的IP地址。本地域名服务器最后把结果告诉主机。

+ **第三步 ：浏览器与目标服务器建立TCP连接**

  + 主机浏览器通过DNS解析得到了目标服务器的IP地址后，与服务器建立TCP连接。
  + TCP3次握手连接：浏览器所在的客户机向服务器发出连接请求报文（SYN标志为1）；服务器接收报文后，同意建立连接，向客户机发出确认报文（SYN，ACK标志位均为1）；客户机接收到确认报文后，再次向服务器发出报文，确认已接收到确认报文；此处客户机与服务器之间的TCP连接建立完成，开始通信。

+ **第四步：浏览器通过http协议发送请求**

  + 浏览器向主机发起一个HTTP-GET方法报文请求。请求中包含访问的URL，也就是http://www.csdn.com/ ，KeepAlive，长连接，还有User-Agent用户浏览器操作系统信息，编码等。值得一提的是Accep-Encoding和Cookies项。Accept-Encoding一般采用gzip，压缩之后传输html文件。Cookies如果是首次访问，会提示服务器建立用户缓存信息，如果不是，可以利用Cookies对应键值，找到相应缓存，缓存里面存放着用户名，密码和一些用户设置项。

+ **第五步：某些服务会做永久重定向响应**

  + 对于大型网站存在多个主机站点，了负载均衡或者导入流量，提高SEO排名，往往不会直接返回请求页面，而是重定向。返回的状态码就不是200OK，而是301,302以3开头的重定向码，浏览器在获取了重定向响应后，在响应报文中Location项找到重定向地址，浏览器重新第一步访问即可。
  + 重定向的作用：重定向是为了负载均衡或者导入流量，提高SEO排名。利用一个前端服务器接受请求，然后负载到不同的主机上，可以大大提高站点的业务并发处理能力；重定向也可将多个域名的访问，集中到一个站点；由于baidu.com，www.baidu.com会被搜索引擎认为是两个网站，照成每个的链接数都会减少从而降低排名，永久重定向会将两个地址关联起来，搜索引擎会认为是同一个网站，从而提高排名。

+ **第六步：浏览器跟踪重定向地址**

  + 当浏览器知道了重定向后最终的访问地址之后，重新发送一个http请求，发送内容同上。

+ **第七步：服务器处理请求**

  + 服务器接收到获取请求，然后处理并返回一个响应。

+ **第八步：服务器发出一个HTML响应**

  + 返回状态码200 OK，表示服务器可以响应请求，返回报文，由于在报头中Content-type为“text/html”，浏览器以HTML形式呈现，而不是下载文件。

+ **第九步：释放TCP连接**

  + 1  浏览器所在主机向服务器发出连接释放报文，然后停止发送数据；
  + 2  服务器接收到释放报文后发出确认报文，然后将服务器上未传送完的数据发送完；
  + 3  服务器数据传输完毕后，向客户机发送连接释放报文；
  + 4  客户机接收到报文后，发出确认，然后等待一段时间后，释放TCP连接；

+ **第十步：浏览器显示页面**

  + 在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了，浏览器接收到返回的数据包，根据浏览器的渲染机制对相应的数据进行渲染。渲染后的数据，进行相应的页面呈现和脚步的交互。

+ **第十一步：浏览器发送获取嵌入在HTML中的其他内容**

  + 比如一些样式文件，图片url，js文件url等，浏览器会通过这些url重新发送请求，请求过程依然是HTML读取类似的过程，查询域名，发送请求，重定向等。不过这些静态文件是可以缓存到浏览器中的，有时访问这些文件不需要通过服务器，直接从缓存中取。某些网站也会使用第三方CDN进行托管这些静态文件。

+ **补充浏览器渲染机制简述**

  + 1  当用户输入一个URL时，浏览器就会向服务器发出一个请求，请求URL对应的资源

  + 2  接受到服务器的响应内容后，浏览器的HTML解析器，会将HTML文件解析成一棵DOM树，DOM树的构建是一个深度遍历的过程，当前节点的所有子节点都构建完成以后，才会去构建当前节点的下一个兄弟节点。

  + 3   将CSS解析成CSSOM树（CSS Rule Tree）

  + 4  根据DOM树和CSSOM树，来构建Render Tree（渲染树）,注意渲染树，并不等于DOM树，因为一些像head或display:none的东西，就没有必要放在渲染树中了。

  + 5  有了Render Tree，浏览器已经能知道网页中有哪些节点，各个节点的CSS定义，以及它们的从属关系，下一步操作就是Layout,顾名思义，就是计算出每个节点在屏幕中的位置。

  + 6  Layout后，浏览器已经知道哪些节点要显示，每个节点的CSS属性是什么，每个节点在屏幕中的位置是哪里，就进入了最后一步painting,按照算出来的规则，通过显卡，把内容画到屏幕上。

  ![img](https://upload-images.jianshu.io/upload_images/13387321-d87d75e05f6ac01f.png?imageMogr2/auto-orient/strip|imageView2/2/w/409/format/webp)

### 61.  CDN

### 62.  DNS

### 63.  Content-Type 有哪些

### 64.  http 请求报文结构

### 65.  HTTP 和 TCP 关系

### 66.  HTTP TCP 属于哪个层

### 67.  浏览器的缓存

+ **1 前言**

  + **浏览器缓存** 是浏览器将用户请求过的静态资源（html、css、js），存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载了，不需要再去服务端请求了。
  + 但也不是说缓存没有缺点，如果处理不当，可能会导致服务端代码更新了，但是用户却还是老页面。所以前端们要针对项目中各个资源的实际情况，做出合理的缓存策略。
  + 缓存的优点：
    + 减少了冗余的数据传输，节省网费
    + 减少服务器的负担，提升网站性能
    + 加快了客户端加载网页的速度

+ **2 缓存流程**

  + 这里先介绍一下浏览器缓存资源的一个大概的流程。

  + 我们可以认为，浏览器里有一个专门存放缓存规则的一个数据库，也可以说是一个映射表，把缓存资源信息，同电脑磁盘中的实际文件的地址，对应起来。（大概意思，别较真）

  + ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4a4eff3a6dd4330bf5b4777e81c5305~tplv-k3u1fbpfcp-watermark.awebp)

  + **浏览器第一次请求资源时**

  + ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b354e0a8cb2450aba81bc12e03d774e~tplv-k3u1fbpfcp-watermark.awebp)

  + 上面所说的 **缓存规则**，就是声明所请求的这个资源，要采取哪种缓存策略？缓存多长时间？等等。。。而这个规则，是在http的header中的返回来的。

  + ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5aaf85ec3b44445fa4953443242be811~tplv-k3u1fbpfcp-watermark.awebp)

  + **注意：** 是response header ，而不是 request header ！！！

    而实际上， request header 中也会携带规则信息，下面会讲，要区分 request 和 response

+ **3  缓存规则**

  + 强缓存和协商缓存。

  + **强缓存**

    简单粗暴，如果资源没过期，就取缓存，如果过期了，则请求服务器。

    如何判断资源是否过期呢，也就是说强缓存的规则怎么看？

    ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fef124c55304637bbf89591ea947131~tplv-k3u1fbpfcp-watermark.awebp)

    主要是看 response headers 中的 Cache-Control 的值，图中的max-age = 31xxxxxxx，就是说在这些秒内，都直接使用缓存，超过了就继续请求服务器

    而和 Cache-Control 并列的，还有一个 Expires ，已经基本淘汰了，所以不用管

    **Cache-Control 的几个取值含义：**

    + **private：** 仅浏览器可以缓存
    + **public：** 浏览器和代理服务器都可以缓存（对于private和public，前端可以认为一样，不用深究）
    + **max-age=xxx** 过期时间（重要）
    + **no-cache**  不进行强缓存（重要）
    + **no-store**   不强缓存，也不协商缓存，基本不用，缓存越多才越好呢

    注意：规则可以同时多个

    ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c50fd6d7f97c41458a2b60cf8c2601af~tplv-k3u1fbpfcp-watermark.awebp)

    所以，对于强缓存，我们主要研究 Cache-Control 中的 max-age 和 no-cache

    所以，判断该资源是否命中强缓存，就看 response 中 Cache-Control 的值，如果有max-age=xxx秒，则命中强缓存。如果Cache-Control的值是no-cache，说明没命中强缓存，走协商缓存。

  + **强缓存流程**

    ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07f8dcf612474aa3b35ebea794f06fbe~tplv-k3u1fbpfcp-watermark.awebp)

    ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c27d01f81b746db9594013415232287~tplv-k3u1fbpfcp-watermark.awebp)

    所以强缓存步骤已经很清晰了：

    + 1  第一次请求 a.js ，缓存表中没该信息，直接请求后端服务器。
    + 2  后端服务器返回了 a.js，且 http response header 中 cache-control 为 max-age=xxxx，所以是强缓存规则，存入缓存表中。
    + 3  第二次请求是 a.js，缓存表中是 max-age，那么命中强缓存，然后判断是否过期，如果没有过期，直接都缓存的 a.js ，如果过期了，则执行协商缓存的步骤

    **注意：**

    ​	这里有个问题，就是 max-age = 0 ，和 no-cache 有啥区别，我理解的是，no-cache直接不进行强缓存，让你去走协商缓存，而max-age=0是进行强缓存，但是过期了，需要更新。。。虽然实际上看起来两者效果是一样的。

  + **协商缓存**

    触发条件：

    + 1  Cache-Control 的值为 no-cache （不强缓存）
    + 2  或者 max-age 过期了 （强缓存，但总有过期的时候）

    也就是说，不管怎样，都可能最后要进行协商缓存（no-store除外）

    ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfd149d78c3e4e25a3d5ce6128bb65b1~tplv-k3u1fbpfcp-watermark.awebp)

    这个图，虽然强缓存命中，但是也有 ETag 和 Last-Modified ，这两个就是协商缓存的相关规则。虽然之前的强缓存流程和他俩没关。。。

    ETag：每个文件有一个，改动文件了就变了，可以看似md5

    Last-Modified：文件的修改时间

    也就是说，每次http返回来 **response** header 中的 ETag和 Last-Modified，在下次请求时在 **request** header 就把这两个带上（但是名字变了ETag-->If-None-Match，Last-Modified-->If-Modified-Since ），服务端把你带过来的标识，资源目前的标识，进行对比，然后判断资源是否更改了。

    这个过程是循环往复的，即缓存表在每次请求成功后都会更新规则。

    **1. 第n次请求成功时：**

    ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae429acb07da4066ba780980451ed8d7~tplv-k3u1fbpfcp-watermark.awebp)

    **2. 缓存表中更新该资源的 ETag 值**

    **3. 第n+1次请求：**

    ​	从缓存表中取该资源最新的ETag，然后加在 request header 中, 注意变名字了，由 ETag -- > If-None-Match

    ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b59c098641a94f4099373b45ad8f572c~tplv-k3u1fbpfcp-watermark.awebp)

    ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58e4541b60f44ff7ac7e9cf6c1242ba0~tplv-k3u1fbpfcp-watermark.awebp)

    ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77ece84bcd294d22bdc966362248663e~tplv-k3u1fbpfcp-watermark.awebp)

    所以协商缓存步骤总结：

    + 1  请求资源时，把用户本地该资源的 ETag 同时带到服务端，服务端和最新资源做对比。
    + 2  如果资源没更改，返回304，浏览器读取本地缓存。
    + 3  如果资源有更改，返回200，返回最新的资源。

+ **4 缓存命中显示**

  + 1  从服务器获取新的资源

    ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/402c62c9bc2d46d485c43abe6205a23f~tplv-k3u1fbpfcp-watermark.awebp)

  + 2  命中强缓存，且资源没过期，直接读取本地缓存

    ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27976c4bcca3415abaca5c85a862afe4~tplv-k3u1fbpfcp-watermark.awebp)

  + 3  命中协商缓存，且资源未更改，读取本地缓存

    ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a9096f25e1846dbac0d7203825ff9ff~tplv-k3u1fbpfcp-watermark.awebp)

    **注意：**协商缓存无论如果，都要向服务端发请求的，只不过，资源未更改时，返回的只是header信息，所以size很小；而资源有更改时，还要返回body数据，所以size会大。

+ **5 总结**

  ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c819577cba3746ddaa2e25a58bed84a4~tplv-k3u1fbpfcp-watermark.awebp)

  ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/244a7d5cf07f421ba9d4e3dbb4a27bf4~tplv-k3u1fbpfcp-watermark.awebp)

### 68.  项目中怎么设置强制缓存

### 69.  this.$nextTick 原理

### 70.  axios,ajax,promise 区别

### 71.  npm git 

## 排序算法

## 二叉树



## 其他（部分面经）

### 1.  职业规划（3-5年）



### 2.  为什么选择前端



### 3.  如何接触前端



### 5.web 端如果要实现按钮事件的绑定是怎么做? onclick addEventListener

### 6. addEventListener有几个参数?响应的含义? 三个 :事件名 函数 捕获还是冒泡阶段

### 7.addEventListener有兼容性的问题吗?那IE响应的是什么方法 ? attachEvent

### 8.如果有1000个按钮,给它们添加点击事件 你会怎么做? 事件委托

### 9.那你用事件委托在点击时是怎么获取到点击对象的呢?event.target 有兼容性问题吗? (只知道有) 那对应的是什么? ev.target || ev.srcElement

### 

### 11.js原生创建一个标签怎么做? .... appendchild是谁调用?

### 13.那如果现在要加100个新标签,怎么做? 一个个加有性能问题吗?

### 14.为什么有性能问题呢?

### 15.重排具体是怎么做的? 只知道需要重新计算元素在页面中的位置信息,重新构建渲染树,其他的就不知道了

### 16.两个元素互换位置怎么实现? 拖拽 那原生js怎么实现? 删除元素用什么?

### 17.js 添加class类名的方法? jQuery呢

### 18.数组常用的方法?push 的返回值? 改变数组本身的方法?

### 19. Set对象? 遍历方法? 怎么转换成数组? Array.from有几个参数?

### 20.用 Array.from创建一个含有5个undefined的数组

### 22.Map和object 的区别?

### 23.跨域问题 ?cors 具体的设置

### 24.post和get的区别?get 能不能在body传参数?get的大小限制是浏览器的限制还是http协议的限制?

### 25.fetch用过吗?浏览器如果不支持fetch 要怎么用fetch

### 26.ajax能上传文件吗?怎么上传?

### 27.状态码 304 ?和200的区别?强缓存呢?expires和cache-control哪个优先级高?不缓存怎么设置

### 

### 29.grid布局了解吗? 

### 30.移动端了解吗?不怎么了解 移动端的兼容问题(说了不了解了,还是继续问) 不了解

### 32.现在使用es6 vue 兼容怎么解决的



### 1. vuex介绍一些?为什么要commit改变状态

### 2. http中是每一次发送请求就要建立连接吗?(长链接)

### 3. 怎么理解http无状态

### 4. 怎么记录登录状态? cookie 和token有什么区别?

### 5. 发送请求的都带cookie吗

### 6. http 与 https 详细讲加密过程? 证书的验证是什么过程?

### 7. 一个类似word分级标题的数据,你希望后端以什么格式给你?

### 8. 那如果后端给的是一个扁平的,你怎么描述树状关系?

### 9. 自己写一个组件,在程序出错的时候用,你会怎么设计?
