# 前端面试常见知识点总结

## HTML

### 1.  H5新增的东西



### 2.  HTML最新哪个版本，之前哪个版本

## CSS

### 1. display：none;  visibility:  hidden； opacity: 0 区别

1. + display: none 隐藏时，该元素不在文档流中占位置；

   + visibility: hidden 隐藏，只是视觉隐藏，还会在文档流中占位置;

   + opacity: 0 隐藏，也会在文档流中占位置，并且可以点击。

2. + display: none 会让元素完全从渲染树中消失，因此会引发回流和重绘；
   + visibility: hidden 不会让元素从渲染树中消失，因此不会引发回流，只会重绘；
   + opacity: 0 不会让元素从渲染树中消失，因此不会引发回流，只会重绘。

3. + display: none 和 opacity: 0是非继承属性，子孙节点消失是因为元素从渲染树中消失，因此修改子节点属性也无法显示；

   + visibility: hidden 是继承属性，子孙节点消失是因为继承了hidden，通过设置visibility: visible，可以让子节点显示。


### 2.  CSS 的 flex 布局

+ flex 弹性布局，有以下六个属性：
  + flex-direction;  flex-wrap;  flex-flow; justify-content; align-items;  align-content;

### 3.  rem  em  px 的区别

+ em 是一个相对长度单位，相对于自身元素的字体大小，如果没有设置，就是相对于父类或者是文档字体大小；
+ rem 也是一个相对长度单位，相对于html的字体大小，一般用于移动端UI适配；
+ px 像素，也是一个相对长度单位，相对于显示器的分辨率

### 4.  line-hight作用



### 5.  CSS3新特性



### 6.  CSS实现动画



### 7. div table布局区别



### 8.  用过什么布局（圣杯，双飞翼？）



### 9. CSS画一个圆



### 10.  实现一个块从左上角到右下角





## JavaScript

### 1.  js为什么是单线程

+ 这是基于js 的用途。js 是浏览器的脚本语言，用于实现用户与浏览器的交互，这就决定了他只能是单线程；
+ 如果是多线程，有两个进程要操作同一个DOM元素，一个删除，一个修改，就会产生矛盾，因此设置为单线程更合适；

### 2.  什么是面向对象

+ 万物皆对象，也可以说，对象是new了一个类的实例，类里有属性和方法；
+ 基本特征有封装，继承，多态
  + 封装：用户在使用的时候不用考虑函数内部代码是如何运行的，只需要会用这个功能就可，
  + 继承：子类可以继承父类的属性和方法，子类自己也有属性和方法
  + 多态： 不同用户去调用一个内容会得到不同的效果

### 3.  undefined null  区别

+ undefined 表示一个变量未定义，不是人为的，部分用法如下：

  + 变量被声明了，但没有赋值时
  + 调用函数时，应该提供的参数没有提供
  + 对象没有赋值的属性
  + 函数没有返回值时

+ null 则表示一个变量被人为的设置为空对象，而不是原始状态，部分用法如下：

  + 作为对象原型链的终点。

  + 作为函数的参数，表示该函数的参数不是对象

    （ 需要传递参数，但是我们暂时不想传递，或者不需要传递，那么我们可以传一个空对象null）

### 4.  setTimeout（如何工作的，如果时间是0怎么办）    setInterval

+ settimeout 是异步任务，在碰到时，会被放入event table 中，等到了时间再推入事件队列中，当主线程执行完毕，空闲时，会执行事件队列中的settimeout
+ setinterval 也是异步任务，时间到了就推入事件队列，，再过这么长时间再推入，一直推。

### 5.  重绘 回流怎么触发

+ 触发（区别）
  + 触发回流：当渲染树的结构，布局，隐藏等发生改变时，就会引发回流（reflow），回流至少发生一次，因为在开始时要构建DOM树，会引发回流。引发回流时，受影响的那部分渲染树会失效，然后重新构建，完成回流后，浏览器会将修改的那部分重新绘制到页面上，称为重绘。
  + 触法重绘：当渲染树中的一部分属性发生修改，只影响外观，比如说背景颜色之类的，不影响布局，就会引发重绘。
+ 注意
  + 回流一定重绘，重绘不一定回流
+ 如何减少
  + 比如要修改同一元素样式的时候，不用一个一个修改，直接创建一个类，这样只引发一次回流；
  + 如果要修改一个DOM元素多条样式时，也可以先隐藏，修改完毕后再显示；
  + ......

### 6.  箭头函数和普通函数区别

+ 箭头函数相当于一个匿名函数，只有一个参数的时候，小括号可以省略，只有一个表达式的时候，大括号可以省略；
+ 箭头函数不能函数提升，也就是说不能先调用，再声明；
+ 箭头函数不能用作构造函数，不能使用new方法；
+ 普通函数this谁调用指向谁，箭头函数指向上下文对象；
+ 箭头函数不能使用arguments，super等方法，不能使用prototype原型对象。

### 7.  数组遍历方法实现reduce



### 8.  同步任务 异步任务

+ 同步任务会进入主线程执行，不会挂载
+ 异步任务不会进入主线程，会进入event table ，达到对应条件就推入事件队列中，主线程空闲，执行事件队列中的任务

### 9.  事件循环

#### 9.1 JavaScript是单线程的，非阻塞的

单线程：

> JavaScript的主要用途是与用户互动，以及操作DOM。如果它是多线程的话，会有很多复杂的问题要处理，比如有两个线程要同时操作DOM，一个线程删除了当前的DOM节点，一个线程要是操作当前的DOM节点，最后应该以哪个线程的操作为准？为了避免这种情况发生，所以JS是单线程的。即使HTML5提出了WebWorker标准，它还是有很多限制，受主线程控制，是主线程的子线程。

非阻塞：

> 通过EventLoop实现

#### 9.2 浏览器的事件循环

##### 执行栈和事件队列

为了更好的理解Event Loop，请看下图（转引自Philip Roberts的演讲[《Help, I'm stuck in an event-loop》](https://link.segmentfault.com/?url=https%3A%2F%2Fvimeo.com%2F96425312)）

<img src="https://segmentfault.com/img/remote/1460000022805527" alt="Help, I'm stuck in an event-loop" style="zoom: 67%;" />

**执行栈**：同步代码的执行，按照顺序添加到执行栈中

```javascript
function a() {
  b();
  console.log('a');
}
function b() {
  console.log('b');
}
a();
```

我们可以通过使用 [Loupe](https://link.segmentfault.com/?url=http%3A%2F%2Flatentflip.com%2Floupe)(Loupe是一种可视化工具，可以帮助您了解JavaScript的调用堆栈/事件循环/回调队列如何相互影响)工具来了解上面代码的执行情况。

> + 执行函数a()先入栈
> + a()中先执行函数b()，函数b()入栈
> + 执行函数b()，console.log('b')入栈
> + 输出b，执行完成，出栈
> + console.log('a')入栈，执行，输出a，出栈
> + 函数a执行完成，出栈。

**事件队列**：异步代码的执行，**遇到异步事件不会等待它返回结果，而是将这个事件挂起**，继续执行**执行栈中的其他任务**。当异步事件返回结果，将它放到事件队列中，**被放入事件队列不会立即执行起回调，而是等待当前执行栈中所有任务都执行完毕**，主线程空闲状态，主线程会去查找事件队列中是否有任务，如果有，**则取出排在第一位的事件**，并把这个事件对应的回调放到执行栈中，然后执行其中的同步代码。

在上面的基础上添加异步事件

```javascript
function a() {
  b();
  console.log('a')
}

function b() {
  console.log('b')
  setTimeout(function () {
    console.log('c')
  },2000)
}

a()
```

下图做总结：

<img src="https://segmentfault.com/img/remote/1460000022805532" alt="执行栈和事件队列" style="zoom:67%;" />

**宏任务和微任务**

为什么要引入微任务，只有一种类型的任务不行吗？

页面渲染事件，各种IO的完成事件等随时被添加到任务队列中，一直会保持先进先出的原则执行，我们不能准确地控制这些事件被添加到任务队列中的位置。但是这个时候突然有高优先级的任务需要尽快执行，那么一种类型的任务就不合适了，所以引入了微任务队列。

不同的异步任务被分为：宏任务和微任务。

**宏任务**：

> + script(整体代码)
> + setTimeout()
> + setInterval()
> + postMessage
> + I/O
> + UI交互事件

微任务：

> + new Promise().then(回调)
> + MutationObserver(HTML5新特性)

**运行机制**

异步任务的返回结果会被放到一个任务队列中，根据异步事件的类型，这个事件实际上会被放到对应的宏任务和微任务队列中去。

在当前执行栈为空时，主线程会查看微任务队列是否有事件存在

+ 存在：依次执行队列中的事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的事件，把当前的回调加到当前执行栈
+ 不存在：再去宏任务队列中取出一个事件并把对应的事件加入当前执行栈

当前执行栈执行完毕后会立刻处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件，同一次事件循环中，微任务永远在宏任务之前执行。

在事件循环中，每进行一次循环操作成为tick，每一次tick的任务处理模型时比较复杂的，但是关键步骤如下：

> + 执行一个宏任务（栈中没有就从事件队列中获取）
> + 执行过程中如果遇到微任务，就把它添加到微任务的任务队列中
> + 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
> + 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
> + 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）

简单总结一下执行的顺序：

执行宏任务，然后执行宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，再回到宏任务中进行下一轮循环。

![宏任务和微任务](https://segmentfault.com/img/remote/1460000022805533)

```javascript
console.log('start')

setTimeout(() => {
    console.log('setTimeout')
}, 0)

Promise.resolve().then(() => {
    console.log('promise1')
}).then(() => {
    console.log('promise2')
})
console.log('end')
```

> 1. 全局代码压入执行栈行，输出start
> 2. setTimeout压入macrotask队列，promise.then回调放入microtask队列，最后执行console.log('end')，输出end
> 3. 调用栈中的代码执行完成（全局代码属于宏任务），接下来开始执行微任务队列中的代码，执行promise回调，输出promise1，promise回调函数默认返回undefined,promise状态变为fulfilled，触发接下来的then回调，继续压入microtask队列，此时产生了新的微任务，会接着把当前的微任务队列执行完，此时执行第二个promise.then回调，输出promise2
> 4. 此时，microtask队列已清空，接下来会执行UI渲染工作（如果有的话），然后开始下一轮事件循环，执行setTimeout的回调，输出setTimeout

#### 9.3 node环境下的事件循环

**和浏览器环境的不同**

表现出的状态和浏览器大致相同，不同的是node中有一套自己的模型。node中事件循环的实现依赖libuv引擎。Node的事件循环存在几个阶段。

如果是node10及其之前版本，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列中的任务。

node版本更新到11以后，eventloop运行原理发生了变化，一旦执行一个阶段里的宏任务（setTimeout,setInterval和setImmediate）就立刻执行微任务队列，跟浏览器趋于一致。下面例子中的代码是按最新的去进行分析的。

**事件循环模型**

```markdown
┌───────────────────────┐
┌─>│        timers         │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     I/O callbacks     │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle, prepare     │
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │   incoming:   │
│  │         poll          │<──connections───     │
│  └──────────┬────────────┘      │   data, etc.  │
│  ┌──────────┴────────────┐      └───────────────┘
│  │        check          │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks    │
   └───────────────────────┘
```

**事件循环各阶段讲解**

node中事件循环的顺序

外部输入数据-->轮询阶段(poll)-->检查阶段(check)-->关闭事件回调阶段(close callback)-->定时器检查阶段(timer)-->I/O事件回调阶段(I/O callbacks)-->闲置阶段(idle,prepare)-->轮询阶段......

这些阶段大致的功能如下：

+ 定时器检测阶段（timers）：这个阶段执行定时器队列中的回调如setTimeout()和setInterval().
+ I/O事件回调阶段（I/O callbacks）：这个阶段执行几乎所有的回调，但是不包括close事件，定时器和setImmediate()的回调。
+ 闲置阶段（idle,prepare）：这个阶段仅在内部使用，可以不必理会。
+ 轮询阶段（poll）：等待新的I/O事件，node在一些特殊情况下会阻塞在这里。
+ 检查阶段（check）：setImmediate()的回调会在这个阶段执行。
+ 关闭事件回调阶段（close callbacks）：例如socket.on('close')这种close事件的回调

poll：
这个阶段是轮询时间，用于等待还未返回的 I/O 事件，比如服务器的回应、用户移动鼠标等等。
这个阶段的时间会比较长。如果没有其他异步任务要处理（比如到期的定时器），会一直停留在这个阶段，等待 I/O 请求返回结果。
check:
该阶段执行setImmediate()的回调函数。

close:
该阶段执行关闭请求的回调函数，比如socket.on('close', ...)。

timer阶段:
这个是定时器阶段，处理setTimeout()和setInterval()的回调函数。进入这个阶段后，主线程会检查一下当前时间，是否满足定时器的条件。如果满足就执行回调函数，否则就离开这个阶段。

I/O callback阶段：
除了以下的回调函数，其他都在这个阶段执行：

- setTimeout()和setInterval()的回调函数
- setImmediate()的回调函数
- 用于关闭请求的回调函数，比如socket.on('close', ...)

**宏任务和微任务**

宏任务：

> + setImmediate
> + setTimeout
> + setInterval
> +  script（整体代码)
> +  I/O 操作等。

微任务：

> + process.nextTick
> + new Promise().then(回调)

#### 9.4 经典题目分析

```javascript
async function async1() {
  console.log('async start')
  await async2();
  console.log('async1 end')
}

async function async2() {
  console.log('async2')
}
console.log('script start')
setTimeout(function () {
  console.log('setTimeout')
}, 0)
async1()
new Promise(function(resolve) {
  console.log('promise1')
  resolve()
}).then(function() {
  console.log('promise2')
})
console.log('script end')
```

> 先执行宏任务（当前代码块也算是宏任务），然后执行当前宏任务产生的微任务，然后接着执行宏任务
>
> 1. 先从上往下执行代码，先执行同步代码，输出script start
> 2. 遇到setTimeout，先把setTimeout的代码放到宏任务队列中
> 3. 执行async1()，输出async1 start，然后执行async2()，输出async2，把async2()后面的代码console.log('async1 end')放到微任务队列中
> 4. 接着往下执行，输出promise1，把.then()放到微任务队列中；注意Promise对象本身是同步的立即执行函数，.then是异步执行函数
> 5. 接着往下执行，输出script end。同步代码（同时也是宏任务）执行完成，接下来开始执行刚才放到微任务队列中的代码
> 6. 依次执行微任务中的代码，依次输出async end1、promise2，微任务中的代码执行完成后，开始执行宏任务中的代码，输出setTimeout

最后的执行结果如下：

- script start
- async1 start
- async2
- promise1
- script end
- async1 end
- promise2
- setTimeout

```javascript
console.log('start');
setTimeout(() => {
    console.log('children2');
    Promise.resolve().then(() => {
        console.log('children3');
    })
}, 0);

new Promise(function(resolve, reject) {
    console.log('children4');
    setTimeout(function() {
        console.log('children5');
        resolve('children6')
    }, 0)
}).then((res) => {
    console.log('children7');
    setTimeout(() => {
        console.log(res);
    }, 0)
})
```

这段代码中会执行多个宏任务，宏任务中又会有很多微任务

> 1. 从上往下执行代码，先执行同步代码，输出start
> 2. 遇到setTimeout，先把setTimeout的代码放到宏任务队列1中
> 3. 接着往下执行，输出children4，然后把setTimeout的代码放到宏任务队列2中
> 4. 代码执行完成以后，会查找微任务队列中的事件，发现并没有，于是开始执行宏任务1，即第一个setTimeout，输出children2，此时会把Promise.resolve().then()放到微任务队列中
> 5. 宏任务1中的代码执行完成后，会检查微任务队列，于是输出children3，然后开始执行宏任务2，即第二个setTimeout，输出children5，此时将then放到微任务队列中
> 6. 宏任务2中代码执行完成后，查找微任务队列，于是输出children7，然后输出children6

最后的执行结果如下：

- start
- children4
- children2
- children3
- children5
- children7
- children6

```javascript
const p = function() {
    return new Promise((resolve, reject) => {
        const p1 = new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve(1)
            }, 0)
            resolve(2)
        })
        p1.then((res) => {
            console.log(res);
        })
        console.log(3);
        resolve(4);
    })
}


p().then((res) => {
    console.log(res);
})
console.log('end');
```

> 1. 执行代码，Promise本身是同步的立即执行函数，.then是异步执行函数。遇到setTimeout，先把其放入宏任务队列中，遇到p1.then会先放到微任务队列中，然后输出3
> 2. 然后p().then放到微任务队列中，输出end
> 3. 然后检查微任务，输出p1().then结果2，然后输出p().then结果4
> 4. 由于p1.then()已经执行完毕，因此setTimeout的resolve不起作用了，结束


### 10.  基本数据类型 引用数据类型 及区别

+ 基本数据类型：数字型，字符串型，null，undefinned，布尔型
+ 引用数据类型：对象（数组，正则，函数）
+ 区别：基本数据类型实际数据放在栈中，而引用数据类型的实际数据放在堆内存中

（栈：自动分配内存空间，由系统自动释放； 堆：动态分配内存空间，大小也不一定会释放）

### 11.   微任务

+ 异步任务分为宏任务、微任务
+ 宏任务：整个script，settimeout，setinterval
+ 微任务：promise，process.nextTick
+ 在执行过程中（首先就是执行一个宏任务），碰到宏任务会被放入宏任务队列中，微任务会被放入微任务队列中，主线程执行完毕，先查看微任务队列，执行完进行渲染，再看宏任务队列，进行第二次循环。

### 12.  js数组扁平化

+ toString split map

### 13. set的各种方法

+ 集合
+ 创建:  new Set();     new Set([1,2,3]);
+ 添加：v.add(2)
+ 大小：v.size
+ 删除：v.delete()
+ 是否有某个元素：v.has()
+ 遍历：for of;  forEach

### 14. map的各种方法

+ 创建： new Map()    或传入一个二维数组
+ 添加：v.set( 'hallo' , 100 )
+ 删除：v.delete('hello')
+ 是否有某个元素：v.has('hello')
+ 获取： v.get('value')

### 15.1 Set Map 的区别

+ map是键值对，set是值的集合
+ map一般用于存储数据，set值不能重复，因此可以用于数组去重
+ map可以用get获取对应的值，set 没有get这个方法

### 15.2  forEach map 的区别





### 16.  js数组方法，哪些可以改变数组本身

+ 数组转字符串：arr.toString( );   arr.join(' ');
  + 不改变数组本身
+ 四个方法：arr.push( ); arr.pop( ); arr.unshift( ); arr.shift( );
  + pop,shift 返回被删除的元素，push，unshift 返回新数组长度
  + 他们都会改变原数组
+ 更改元素：arr[index] = n
  + 更改原数组
+ 末尾追加元素：arr[arr.length] = n (相当于push，也会改变数组本身)
+ 删除元素： delete arr[index] 或直接删除数组 ：delete arr
  + 会改变数组本身，删除元素的位置空出来undefined
+ arr.concat( );  arr.slice( ); arr.splice( );
  + arr.concat(arr1, arr2) 或 arr.concat( 'gf', 'hj' ); (不改变原数组)
  + arr.slice( ); 截取，从第几个到第几个，省略第二个表示到最后。（不改变原数组）
  + arr.splice( ); 第一个是从哪里开始，第二个是删除几个，后面的全是添加的元素
    + 返回删除的元素，改变原数组

### 17.  栈，队列，链表（js如何实现）



### 18.  order的理解



### 19.  什么是闭包，哪里用到了闭包



### 20.  es6新特性(展开说)



### 21.  递归可以转换成迭代吗



### 22.  TS 对比 JS 



### 23.  JS怎么实现类型检查



### 24.  开发PC端页面和移动端页面分别要考虑什么问题



### 25.  如何构造类



### 26.  事件冒泡和事件代理



### 27.  删除一个DOM节点的方法



### 28.  给两个数组，去重，合并









## Vue（ + http)

### 1.  Vue 2.0 Vue 3.0 区别



### 2.  Vue生命周期

+ 首先new 一个Vue组件

+ 初始化事件和生命周期函数

+ + beforeCreate 准备创建props，data，methods，但是现在还不能用

+ 初始化props，data，methods

+ + created 已经创建props，data，methods，但是组件模板结构尚未生成（在这个阶段可以发起AJAX请求）

+ 接下来的几步就是根据数据和模板，在内存中编译生成HTML结构

  （1 . 是否有el , 若没有看是否有$mount(el), 

   	2.  是否有template.  有就编译template中的HTML，没有就编译el指向的HTML结构）

+ + beforeMount 将要把内存中编译好的HTML结构渲染到浏览器中

+ 用内存中生成的HTML结构替换el 指向的DOM结构

+ + mounted 已经把内存中生成的HTML结构渲染到浏览器中

+ 当数据发生变化时

+ + beforeUpdated 将要根据变化后最新的数据重新渲染模板结构

+ 根据变化后最新的数据重新渲染模板结构

+ + updated 完成了重新渲染模板结构

+ 要进行销毁时

+ + beforeDestory 即将销毁组件

+ 准备销毁数据侦听器，子组件，事件监听

+ + destoryed 已经完全销毁DOM结构

### 3.  watch computed methods区别



### 4.  v-if v-for 以及v-if v-show区别



### 5.1  Vue父子组件之间如何传值



### 5.2  兄弟组件的通信方式



### 6.1  讲讲单页面应用和多页面应用



### 6.2  如何解决单页面应用首页加载慢的问题



### 7.   Vue数据流



### 8. Vue双向数据绑定



### 9.  webpack是什么



### 10. 怎么提高打包速度，减少打包体积



### 11.  Vue 技术栈



### 12.  说说 promise 的 async  await



### 13.  promise有哪些方法，all  race 方法以及应用场景



### 14.  cookie 和 webstorage区别

+ 特性
  + cookie 由服务器生成，存储在浏览器的，可以设置失效时间
  + localstorage 除非主动删除，否则即使浏览器关闭内容也不会清除
  + sessionstorage 浏览器关闭后数据会自动删除
+ 大小
  + cookie 可以存储大小约为4KB 
  + webstorage 可以存储大小为5MB左右
+ 与服务器
  + cookie 由服务器生成，发送给服务器，会在服务器下一次请求时被携带
  + webstorage 与服务器没有联系
+ 接口
  + cookie 接口原生的不友好，需要程序员自己封装
  + webstorage 原生接口就可以

### 15.  cookie怎么保存到本地的，cookie怎么实现跨域



### 16.  跨域相关问题



### 17.  常见状态码

+ 200： OK
+ 301：永久重定向
+ 302：临时重定向
+ 303：临时重定向，可以使用get获取到新的URL
+ 304：上次请求的网页未修改（可以进行强制刷新）
+ 401：未授权
+ 403：禁止访问
+ 404：找不到资源

### 18.  v-for 中 key 的作用，没有 key 会怎么样

+ 在写v-for的时候必须要加key，作为唯一标识，可以提高渲染性能，防止数据混乱。

### 19.  观察者模式三个类



### 20.  token session的区别



### 21.  TCP三次握手，为什么有三次握手



### 22.  https 用了对称加密和非对称加密吗？为什么使用对称加密？



### 23.  动态数组在尾部插入一个元素，时间复杂度，空间复杂度



### 24.  数组和链表的区别



### 25.  节流 防抖



### 26.  vue  diff算法（以及虚拟DOM变化及处理）



### 27.  vue响应式原理



### 28.  Vue源码解析


### 29.  单例模式



### 30.  浏览器缓存（什么时候用）



### 31.  Vue怎么更新组件



### 32.  组件通信方式



### 33.  浏览器请求方式



### 34.  Ajax怎么实现异步通信



### 35.  插槽的使用



### 36. 如何实现页面跳转，路由跳转怎么实现



### 37.  vue 和 js 的关系



### 38.  vue 的原理或特性



### 39.  vue什么组件能实现增删改



### 40.  前端安全  xsrf怎么防御



### 41.  http组成部分



### 42.  响应头部



### 43.  数据结hash



### 44.  vue Router



### 45.  网络协议



### 46.  socket了解吗



### 47.  vue的特点 优点



### 48.  vuex的使用场景



### 49.  Ajax实现过程，和promise区别



### 50.  http https 区别，http 如何升级到 https



### 51.  前端各种性能提升



### 52. has history 的区别











## 其他（部分面经）

### 1.  职业规划（3-5年）



### 2.  为什么选择前端



### 3.  如何接触前端



### 5.web 端如果要实现按钮事件的绑定是怎么做? onclick addEventListener

### 6. addEventListener有几个参数?响应的含义? 三个 :事件名 函数 捕获还是冒泡阶段

### 7.addEventListener有兼容性的问题吗?那IE响应的是什么方法 ? attachEvent

### 8.如果有1000个按钮,给它们添加点击事件 你会怎么做? 事件委托

### 9.那你用事件委托在点击时是怎么获取到点击对象的呢?event.target 有兼容性问题吗? (只知道有) 那对应的是什么? ev.target || ev.srcElement

### 10.事件委托的好处

### 11.js原生创建一个标签怎么做? .... appendchild是谁调用?

### 13.那如果现在要加100个新标签,怎么做? 一个个加有性能问题吗?

### 14.为什么有性能问题呢?

### 15.重排具体是怎么做的? 只知道需要重新计算元素在页面中的位置信息,重新构建渲染树,其他的就不知道了

### 16.两个元素互换位置怎么实现? 拖拽 那原生js怎么实现? 删除元素用什么?

### 17.js 添加class类名的方法? jQuery呢

### 18.数组常用的方法?push 的返回值? 改变数组本身的方法?

### 19. Set对象? 遍历方法? 怎么转换成数组? Array.from有几个参数?

### 20.用 Array.from创建一个含有5个undefined的数组

### 21.判断数组的方法? 能不能用数组的tostring方法?

### 22.Map和object 的区别?

### 23.跨域问题 ?cors 具体的设置

### 24.post和get的区别?get 能不能在body传参数?get的大小限制是浏览器的限制还是http协议的限制?

### 25.fetch用过吗?浏览器如果不支持fetch 要怎么用fetch

### 26.ajax能上传文件吗?怎么上传?

### 27.状态码 304 ?和200的区别?强缓存呢?expires和cache-control哪个优先级高?不缓存怎么设置

### 28.箭头函数可以new吗

### 29.grid布局了解吗? 

### 30.移动端了解吗?不怎么了解 移动端的兼容问题(说了不了解了,还是继续问) 不了解

### 31.vue用了多久?常用的指令?v-if 和 v-for能一起用? v-show和v-if 的区别

### 32.现在使用es6 vue 兼容怎么解决的

### 32.对其他方面还有感兴趣的

### 33.数组和 链表 的区别?查找元素哪个效率高?删除元素哪个效率改?

### 34.性格是内向还是外向?

### 35.选公司看重什么?

### 36.能接受加班吗?

### 37.有什么想问的吗?


二面



### 1. vuex介绍一些?为什么要commit改变状态

### 2. http中是每一次发送请求就要建立连接吗?(长链接)

### 3. 怎么理解http无状态

### 4. 怎么记录登录状态? cookie 和token有什么区别?

### 5. 发送请求的都带cookie吗

### 6. http 与 https 详细讲加密过程? 证书的验证是什么过程?

### 7. 一个类似word分级标题的数据,你希望后端以什么格式给你?

### 8. 那如果后端给的是一个扁平的,你怎么描述树状关系?

### 9. 自己写一个组件,在程序出错的时候用,你会怎么设计?