# 前端面试常见知识点总结

## HTML

### 1.  H5新增的东西



### 2.  HTML最新哪个版本，之前哪个版本



### 3.  语义化怎么理解（为什么语义化）



### 4. HTML块级元素和 行内元素有哪些？ 区别？ 怎么互相转变

+ 块级元素
  + 每个块级元素通常都会独占一行或者是多行，可以对其单独设置高度,宽度以及对齐等属性。
  + 常见的块级元素有：<h1>~<h6>,<p>,<div>,<ul>,<ol>,<li>	等
  + 块级元素的特点：
    + 块级元素会独占一行
    + 高度，行高，外边距和内边距都可以单独设置
    + 宽度默认是容器的100%
    + 可以容纳内联元素和其他的块级元素
+ 行内元素
  + 不占有独立的区域，仅仅依靠自己的字体大小或者是图像大小来支撑结构。一般不可以设置宽度，高度以及对齐等属性。
  + 常见的行内元素有：<a>,<strong>,<b>,<em>,<del>,<span>等
  + 行内元素的特点：
    + 和相邻的行内元素在一行上
    + 高度和宽度无效，但是水平方向上的padding和margin可以设置，垂直方向上的无效
    + 默认的宽度就是它本身的宽度
    + 行内元素只能容纳纯文本或者是其他的行内元素（a标签除外）
+ 注意：
  + 只有文字才能组成段落，因此类似<p>,<h1>~<h6>,<dt>等里面不能放块级元素；因为它们都是文字块级标签，里面不能再存放其他的块级标签。
  + 链接里面不能再存放链接
+ 行内块级元素
  + 在行内元素中有几个特殊的标签，<img/>,<input/>,<td/>,可以设置它们的宽高度以及对齐属性
  + 行内块级元素的特点：
    + 和相邻的行内元素（行内块）在一行上，但是中间会有空白的间隙
    + 默认的宽度就是本身内容的宽度
    + 高度，行高，内边距和外边距都可以设置
+ 显示模式的转换
  + 块转行内：display-inline；
  + 行内转块：display：block；
  + 块，行内元素转换为行内块：display：inline-block



## CSS

### 1. display：none;  visibility:  hidden； opacity: 0 区别

1. + display: none 隐藏时，该元素不在文档流中占位置；

   + visibility: hidden 隐藏，只是视觉隐藏，还会在文档流中占位置;

   + opacity: 0 隐藏，也会在文档流中占位置，并且可以点击。

2. + display: none 会让元素完全从渲染树中消失，因此会引发回流和重绘；
   + visibility: hidden 不会让元素从渲染树中消失，因此不会引发回流，只会重绘；
   + opacity: 0 不会让元素从渲染树中消失，因此不会引发回流，只会重绘。

3. + display: none 和 opacity: 0是非继承属性，子孙节点消失是因为元素从渲染树中消失，因此修改子节点属性也无法显示；

   + visibility: hidden 是继承属性，子孙节点消失是因为继承了hidden，通过设置visibility: visible，可以让子节点显示。


### 2.  CSS 的 flex 布局

flex 弹性布局，有以下六个属性：

+ flex-direction;  flex-wrap;  flex-flow; justify-content; align-items;  align-content;

+ 1》水平（主轴上）对齐方式：

  justify-content：flex-start | flex-end | center | space-between | space-around

+ 2》十字交叉轴上对齐方式

  align-items：flex-start | flex-end | center | baseline | stretch;

+ 3》项目排列方向

  flex-direction：row | row-reverse | column | column-reverse;

+ 4》换行方式

  flex-wrap：nowrap（不换行） | wrap（向下换） | wrap-reverse（向上换）;

+ 5》flex-flow

  flex-direction和flex-wrap的简写

+ 6》多根轴线的对齐方式

  align-content：flex-start | flex-end | center | space-between | space-around | stretch;

子项目属性：

+ order:         
  + 定义项目的排列顺序。数值越小，排列越靠前，默认为0。
+ flex-grow:  
  +  定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。  
  +  如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。                 
  +  如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 
+ flex-shrink: 
  + 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
  + 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。                 
  + 如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。
+ flex-basis:  
  + 定义了在分配多余空间之前，项目占据的主轴空间（main size）
+ flex:           
  + 属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。                 
  + 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 
+ align-self:  
  +  属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。                 
  +  默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。

### 3.  rem  em  px 的区别

+ em 是一个相对长度单位，相对于自身元素的字体大小，如果没有设置，就是相对于父类或者是文档字体大小；
+ rem 也是一个相对长度单位，相对于html的字体大小，一般用于移动端UI适配；
+ px 像素，也是一个相对长度单位，相对于显示器的分辨率

### 4.  line-hight作用



### 5.  CSS3新特性



### 6.  CSS实现动画



### 7. div table布局区别



### 8.  用过什么布局（圣杯，双飞翼？两栏，三栏？）



### 9. CSS画一个圆



### 10.  实现一个块从左上角到右下角



### 11. 盒子模型

+ 盒子模型由四部分组成：内容区（content）、填充(padding)、边框(border)和外边距(margin)
+ 内容区（content）
  + 内容区有三个属性，width、height 和overflow。
  + 使用width和height属性可以指定盒子内容区的高度和宽度，
  + 当内容信息太多，超出内容区所占范围时，可以使用overflow 溢出属性来指定处理方法。
    + 当overflow 属性值为hidden时，溢出部分将不可见；
    + 为visible时，溢出的内容信息可见，只是被呈现在盒子的外部；
    + 当为scroll时，滚动条将被自动添加到盒子中，用户可以通过拉动滚动条显示内容信息；
    + 当为auto时，将由浏览器决定如何处理溢出部分。
+ 填充（padding）
  + 填充是内容区和[边框](https://baike.baidu.com/item/边框/7166650)之间的空间。
  + 填充的属性有五种 ，即padding -top、padding -bottom、padding -left、padding-right 以及综合了以上四种方向的快捷填充属性padding。
+ 边框（border）
  + [边框](https://baike.baidu.com/item/边框/7166650)是环绕内容区和填充的边界。
  + 边框的属性有border-style、border-width和border-color 以及综合了以上三类属性的快捷边框属性 border。
  + border-style 属性是边框最重要的属性，如果没有指定边框样式，其他的边框属性都会被忽略，边框将不存在。CSS规定了dotted（点线）、dashed（虚线）、solid(实线)等九种边框样式。
  + 使用border-width属性可以指定边框的宽度，其属性值可以是长度计量值，也可以是CSS规定的thin、medium 和thick。
  + 使用border-color属性可以为边框指定相应的颜色，其属性值可以是[RGB](https://baike.baidu.com/item/RGB/342517)值，也可以是CSS 规定的17个颜色名 。
  + 在设定以上三种边框属性时，既可以进行边框四个方向整体的快捷设置，也可以进行四个方向的专向设置，如border: 2px solid green 或border-top-style: solid、border-left-color: red等。
  + 设置盒子背景色属性时，在IE中背景不会延伸到边框区域，但在FF等标准浏览器中，背景颜色可以延伸到边框区域，特别是单边框设置为点线或虚线时能看到效果 。
+ 空白边（margin）
  + 空白边位于盒子的最外围，是添加在边框外周围的空间。
  + 空白边的属性有五种 ，即margin-top、margin-bottom、margin- left、margin-right以及综合了以上四种方向的快捷空白边属性margin，其具体的设置和使用与填充属性类似。
+ 盒子模型分为两类：W3C盒模型（标准盒模型），IE盒模型（怪异盒模型）
+ W3C盒模型（标准盒模型）
  + box-sizing : content-box（默认）
  + 设置的宽度是内容的宽度，整个盒子模型总体的宽度 = 设置的宽度 + 左右内边距 + 左右边框 + 左右外边距
+ IE盒模型（怪异盒模型）
  + box-sizing： border-box
  + 设置的宽度是除外边距外的所有宽度，整个盒子模型总体的宽度 = 设置的宽度 + 左右外边距

### 12. position

+ **关于CSS position，来自MDN的描述：**

> CSS position属性用于指定一个元素在文档中的定位方式。top、right、bottom、left 属性则决定了该元素的最终位置。

​	然后来看看什么是文档流(normal flow)，下面是 [www.w3.org](https://www.w3.org/TR/CSS21/visuren.html#) 的描述：

> **Normal flow**
>
> Boxes in the normal flow belong to a formatting context, which may be block or inline, but not both simultaneously. [Block-level](https://www.w3.org/TR/CSS21/visuren.html#block-level) boxes participate in a [block formatting](https://www.w3.org/TR/CSS21/visuren.html#block-formatting) context. [Inline-level boxes](https://www.w3.org/TR/CSS21/visuren.html#inline-level) participate in an [inline formatting](https://www.w3.org/TR/CSS21/visuren.html#inline-formatting) context.

​		个人补充（此处参考[FungLeo](https://blog.csdn.net/fungleo)的博客文章，[原文点此](https://blog.csdn.net/fungleo/article/details/50056111)）：

1. normal flow直译为常规流、正常流，国内不知何原因大多译为文档流；
2. 窗体自上而下分成一行一行，并在每行中按从左至右的顺序排放元素；
3. 每个非浮动块级元素都独占一行， 浮动元素则按规定浮在行的一端，若当前行容不下，则另起新行再浮动；
4. 内联元素也不会独占一行，几乎所有元素(包括块级，内联和列表元素）均可生成子行，用于摆放子元素；
5. 有三种情况将使得元素脱离normal flow而存在，分别是 float，absolute ，fixed，但是在IE6中浮动元素也存在于normal flow中。

+ **一、position: static**

MDN的描述：

> 该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top、right、bottom、left 属性无效。

个人补充：static是position的默认值。



```
 1 <!DOCTYPE html>
 2 <html lang="en">
 3 <head>
 4     <meta charset="UTF-8">
 5     <title>CSS-position-static</title>
 6     <link rel="stylesheet" href="https://cdn.bootcss.com/normalize/8.0.0/normalize.css">
 7     <style>
 8         .container{
 9             background-color: #868686;
10             width: 100%;
11             height: 300px;
12         }
13         .content{
14             background-color: yellow;
15             width: 100px;
16             height: 100px;
17             position: static;
18             left: 10px;/* 这个left没有起作用 */
19         }
20     </style>
21 </head>
22 <body>
23     <div class="container">
24         <div class="content">    
25         </div>
26     </div>
27 </body>
28 </html>
```



![img](https://files.cnblogs.com/files/guolao/static.bmp)

对 content 的 position 设定 static 后，left就失效了，而元素（content）就以正常的 normal flow 形式呈现。

+ **二、position: relative**

MDN的描述：

> 该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。position:relative 对 table-*-group, table-row, table-column, table-cell, table-caption 元素无效。

个人理解：相对于normal flow中的原位置来定位。

![img](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif) position: relative

![img](https://files.cnblogs.com/files/guolao/relative_0.bmp)

这是没有设置left、top等属性时，正常出现在normal flow中的位置。

接着添加left、top：



```
1 .content_1{
2                 background-color: red;
3                 width: 100px;
4                 height: 100px;
5                 position: relative;/* 这里使用了relative  */
6                 left: 20px;/* 这里设置了left和top */
7                 top: 20px;            
8             }
```



![img](https://files.cnblogs.com/files/guolao/relative_1.bmp)

可以看到，元素（content_1）的位置相对于其原位置（normal flow中的正常位置）进行了移动。

+ **三、position: absolute**

MDN的描述

> 不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margin），且不会与其他边距合并。

个人理解：生成绝对定位的元素，其相对于 static 定位以外的第一个父元素进行定位,会脱离normal flow。**注意：是除了static外**

![img](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif) position: absolute

![img](https://files.cnblogs.com/files/guolao/absolute.bmp)

因为 content 的父元素 container 没有设置 position，默认为 static，所以找到的第一个父元素是 body（<body></body>），可以看成是元素（content）相对于 body 向下移动10px。

+ **四、position: fixed**

MDN的描述

> 不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed属性会创建新的层叠上下文。当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。

个人理解：fixed相对于window固定，滚动浏览器窗口并不会使其移动，会脱离normal flow。

![img](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif) position: fixed

这里就不上图了，看一下代码或者自己动手码一下就能理解。

+ **五、position: sticky**

  MDN的描述

> 盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 table`时`），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。position: sticky对 table元素的效果与 position: relative 相同。

因为各大浏览器对于sticky的兼容问题，而且JS也可以实现这个功能，在这里就不进行深入了，了解一下就好。

+ 六、**position: inherit**

  [w3school.com](http://www.w3school.com.cn/cssref/pr_class_position.asp)的 描述

  规定应该从父元素继承 position 属性的值。

  inherit 继承父元素，这个用得不多，所以也不继续深入了。

### 13.  伪类、伪元素

### 14.  选择器优先级

### 15.  怎么设置0.5px边框

### 16.  sass，less 区别



## JavaScript

### 1.  js为什么是单线程

+ 这是基于js 的用途。js 是浏览器的脚本语言，用于实现用户与浏览器的交互，这就决定了他只能是单线程；
+ 如果是多线程，有两个进程要操作同一个DOM元素，一个删除，一个修改，就会产生矛盾，因此设置为单线程更合适；

### 2.  什么是面向对象（待补充）

+ 万物皆对象，也可以说，对象是new了一个类的实例，类里有属性和方法；
+ 基本特征有封装，继承，多态
  + 封装：用户在使用的时候不用考虑函数内部代码是如何运行的，只需要会用这个功能就可，
  + 继承：子类可以继承父类的属性和方法，子类自己也有属性和方法
  + 多态： 不同用户去调用一个内容会得到不同的效果

### 3.  undefined null  区别

+ undefined 表示一个变量未定义，不是人为的，部分用法如下：

  + 变量被声明了，但没有赋值时
  + 调用函数时，应该提供的参数没有提供
  + 对象没有赋值的属性
  + 函数没有返回值时

+ null 则表示一个变量被人为的设置为空对象，而不是原始状态，部分用法如下：

  + 作为对象原型链的终点。

  + 作为函数的参数，表示该函数的参数不是对象

    （ 需要传递参数，但是我们暂时不想传递，或者不需要传递，那么我们可以传一个空对象null）

### 4.  setTimeout（如何工作的，如果时间是0怎么办）    setInterval

+ settimeout 是异步任务，在碰到时，会被放入event table 中，等到了时间再推入事件队列中，当主线程执行完毕，空闲时，会执行事件队列中的settimeout
+ setinterval 也是异步任务，时间到了就推入事件队列，，再过这么长时间再推入，一直推。

### 5.  重绘 回流怎么触发

+ 触发（区别）
  + 触发回流：当渲染树的结构，布局，隐藏等发生改变时，就会引发回流（reflow），回流至少发生一次，因为在开始时要构建DOM树，会引发回流。引发回流时，受影响的那部分渲染树会失效，然后重新构建，完成回流后，浏览器会将修改的那部分重新绘制到页面上，称为重绘。
  + 触法重绘：当渲染树中的一部分属性发生修改，只影响外观，比如说背景颜色之类的，不影响布局，就会引发重绘。
+ 注意
  + 回流一定重绘，重绘不一定回流
+ 如何减少
  + 比如要修改同一元素样式的时候，不用一个一个修改，直接创建一个类，这样只引发一次回流；
  + 如果要修改一个DOM元素多条样式时，也可以先隐藏，修改完毕后再显示；
  + ......

### 6.  箭头函数和普通函数区别

+ 箭头函数相当于一个匿名函数，只有一个参数的时候，小括号可以省略，只有一个表达式的时候，大括号可以省略；
+ 箭头函数不能函数提升，也就是说不能先调用，再声明；
+ 箭头函数不能用作构造函数，不能使用new方法；
+ 普通函数this谁调用指向谁，箭头函数指向上下文对象；
+ 箭头函数不能使用arguments，super等方法，不能使用prototype原型对象。

### 7.  数组遍历方法实现reduce



### 8.  同步任务 异步任务

+ 同步任务会进入主线程执行，不会挂载
+ 异步任务不会进入主线程，会进入event table ，达到对应条件就推入事件队列中，主线程空闲，执行事件队列中的任务

### 9.  事件循环

#### 9.1 JavaScript是单线程的，非阻塞的

单线程：

> JavaScript的主要用途是与用户互动，以及操作DOM。如果它是多线程的话，会有很多复杂的问题要处理，比如有两个线程要同时操作DOM，一个线程删除了当前的DOM节点，一个线程要是操作当前的DOM节点，最后应该以哪个线程的操作为准？为了避免这种情况发生，所以JS是单线程的。即使HTML5提出了WebWorker标准，它还是有很多限制，受主线程控制，是主线程的子线程。

非阻塞：

> 通过EventLoop实现

#### 9.2 浏览器的事件循环

##### 执行栈和事件队列

为了更好的理解Event Loop，请看下图（转引自Philip Roberts的演讲[《Help, I'm stuck in an event-loop》](https://link.segmentfault.com/?url=https%3A%2F%2Fvimeo.com%2F96425312)）

<img src="https://segmentfault.com/img/remote/1460000022805527" alt="Help, I'm stuck in an event-loop" style="zoom: 67%;" />

**执行栈**：同步代码的执行，按照顺序添加到执行栈中

```javascript
function a() {
  b();
  console.log('a');
}
function b() {
  console.log('b');
}
a();
```

我们可以通过使用 [Loupe](https://link.segmentfault.com/?url=http%3A%2F%2Flatentflip.com%2Floupe)(Loupe是一种可视化工具，可以帮助您了解JavaScript的调用堆栈/事件循环/回调队列如何相互影响)工具来了解上面代码的执行情况。

> + 执行函数a()先入栈
> + a()中先执行函数b()，函数b()入栈
> + 执行函数b()，console.log('b')入栈
> + 输出b，执行完成，出栈
> + console.log('a')入栈，执行，输出a，出栈
> + 函数a执行完成，出栈。

**事件队列**：异步代码的执行，**遇到异步事件不会等待它返回结果，而是将这个事件挂起**，继续执行**执行栈中的其他任务**。当异步事件返回结果，将它放到事件队列中，**被放入事件队列不会立即执行起回调，而是等待当前执行栈中所有任务都执行完毕**，主线程空闲状态，主线程会去查找事件队列中是否有任务，如果有，**则取出排在第一位的事件**，并把这个事件对应的回调放到执行栈中，然后执行其中的同步代码。

在上面的基础上添加异步事件

```javascript
function a() {
  b();
  console.log('a')
}

function b() {
  console.log('b')
  setTimeout(function () {
    console.log('c')
  },2000)
}

a()
```

下图做总结：

<img src="https://segmentfault.com/img/remote/1460000022805532" alt="执行栈和事件队列" style="zoom:67%;" />

**宏任务和微任务**

为什么要引入微任务，只有一种类型的任务不行吗？

页面渲染事件，各种IO的完成事件等随时被添加到任务队列中，一直会保持先进先出的原则执行，我们不能准确地控制这些事件被添加到任务队列中的位置。但是这个时候突然有高优先级的任务需要尽快执行，那么一种类型的任务就不合适了，所以引入了微任务队列。

不同的异步任务被分为：宏任务和微任务。

**宏任务**：

> + script(整体代码)
> + setTimeout()
> + setInterval()
> + postMessage
> + I/O
> + UI交互事件

微任务：

> + new Promise().then(回调)
> + MutationObserver(HTML5新特性)

**运行机制**

异步任务的返回结果会被放到一个任务队列中，根据异步事件的类型，这个事件实际上会被放到对应的宏任务和微任务队列中去。

在当前执行栈为空时，主线程会查看微任务队列是否有事件存在

+ 存在：依次执行队列中的事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的事件，把当前的回调加到当前执行栈
+ 不存在：再去宏任务队列中取出一个事件并把对应的事件加入当前执行栈

当前执行栈执行完毕后会立刻处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件，同一次事件循环中，微任务永远在宏任务之前执行。

在事件循环中，每进行一次循环操作成为tick，每一次tick的任务处理模型时比较复杂的，但是关键步骤如下：

> + 执行一个宏任务（栈中没有就从事件队列中获取）
> + 执行过程中如果遇到微任务，就把它添加到微任务的任务队列中
> + 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
> + 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
> + 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）

简单总结一下执行的顺序：

执行宏任务，然后执行宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，再回到宏任务中进行下一轮循环。

![宏任务和微任务](https://segmentfault.com/img/remote/1460000022805533)

```javascript
console.log('start')

setTimeout(() => {
    console.log('setTimeout')
}, 0)

Promise.resolve().then(() => {
    console.log('promise1')
}).then(() => {
    console.log('promise2')
})
console.log('end')
```

> 1. 全局代码压入执行栈行，输出start
> 2. setTimeout压入macrotask队列，promise.then回调放入microtask队列，最后执行console.log('end')，输出end
> 3. 调用栈中的代码执行完成（全局代码属于宏任务），接下来开始执行微任务队列中的代码，执行promise回调，输出promise1，promise回调函数默认返回undefined,promise状态变为fulfilled，触发接下来的then回调，继续压入microtask队列，此时产生了新的微任务，会接着把当前的微任务队列执行完，此时执行第二个promise.then回调，输出promise2
> 4. 此时，microtask队列已清空，接下来会执行UI渲染工作（如果有的话），然后开始下一轮事件循环，执行setTimeout的回调，输出setTimeout

#### 9.3 node环境下的事件循环

**和浏览器环境的不同**

表现出的状态和浏览器大致相同，不同的是node中有一套自己的模型。node中事件循环的实现依赖libuv引擎。Node的事件循环存在几个阶段。

如果是node10及其之前版本，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列中的任务。

node版本更新到11以后，eventloop运行原理发生了变化，一旦执行一个阶段里的宏任务（setTimeout,setInterval和setImmediate）就立刻执行微任务队列，跟浏览器趋于一致。下面例子中的代码是按最新的去进行分析的。

**事件循环模型**

```markdown
┌───────────────────────┐
┌─>│        timers         │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     I/O callbacks     │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle, prepare     │
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │   incoming:   │
│  │         poll          │<──connections───     │
│  └──────────┬────────────┘      │   data, etc.  │
│  ┌──────────┴────────────┐      └───────────────┘
│  │        check          │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks    │
   └───────────────────────┘
```

**事件循环各阶段讲解**

node中事件循环的顺序

外部输入数据-->轮询阶段(poll)-->检查阶段(check)-->关闭事件回调阶段(close callback)-->定时器检查阶段(timer)-->I/O事件回调阶段(I/O callbacks)-->闲置阶段(idle,prepare)-->轮询阶段......

这些阶段大致的功能如下：

+ 定时器检测阶段（timers）：这个阶段执行定时器队列中的回调如setTimeout()和setInterval().
+ I/O事件回调阶段（I/O callbacks）：这个阶段执行几乎所有的回调，但是不包括close事件，定时器和setImmediate()的回调。
+ 闲置阶段（idle,prepare）：这个阶段仅在内部使用，可以不必理会。
+ 轮询阶段（poll）：等待新的I/O事件，node在一些特殊情况下会阻塞在这里。
+ 检查阶段（check）：setImmediate()的回调会在这个阶段执行。
+ 关闭事件回调阶段（close callbacks）：例如socket.on('close')这种close事件的回调

poll：
这个阶段是轮询时间，用于等待还未返回的 I/O 事件，比如服务器的回应、用户移动鼠标等等。
这个阶段的时间会比较长。如果没有其他异步任务要处理（比如到期的定时器），会一直停留在这个阶段，等待 I/O 请求返回结果。
check:
该阶段执行setImmediate()的回调函数。

close:
该阶段执行关闭请求的回调函数，比如socket.on('close', ...)。

timer阶段:
这个是定时器阶段，处理setTimeout()和setInterval()的回调函数。进入这个阶段后，主线程会检查一下当前时间，是否满足定时器的条件。如果满足就执行回调函数，否则就离开这个阶段。

I/O callback阶段：
除了以下的回调函数，其他都在这个阶段执行：

- setTimeout()和setInterval()的回调函数
- setImmediate()的回调函数
- 用于关闭请求的回调函数，比如socket.on('close', ...)

**宏任务和微任务**

宏任务：

> + setImmediate
> + setTimeout
> + setInterval
> +  script（整体代码)
> +  I/O 操作等。

微任务：

> + process.nextTick
> + new Promise().then(回调)

#### 9.4 经典题目分析

```javascript
async function async1() {
  console.log('async start')
  await async2();
  console.log('async1 end')
}

async function async2() {
  console.log('async2')
}
console.log('script start')
setTimeout(function () {
  console.log('setTimeout')
}, 0)
async1()
new Promise(function(resolve) {
  console.log('promise1')
  resolve()
}).then(function() {
  console.log('promise2')
})
console.log('script end')
```

> 先执行宏任务（当前代码块也算是宏任务），然后执行当前宏任务产生的微任务，然后接着执行宏任务
>
> 1. 先从上往下执行代码，先执行同步代码，输出script start
> 2. 遇到setTimeout，先把setTimeout的代码放到宏任务队列中
> 3. 执行async1()，输出async1 start，然后执行async2()，输出async2，把async2()后面的代码console.log('async1 end')放到微任务队列中
> 4. 接着往下执行，输出promise1，把.then()放到微任务队列中；注意Promise对象本身是同步的立即执行函数，.then是异步执行函数
> 5. 接着往下执行，输出script end。同步代码（同时也是宏任务）执行完成，接下来开始执行刚才放到微任务队列中的代码
> 6. 依次执行微任务中的代码，依次输出async end1、promise2，微任务中的代码执行完成后，开始执行宏任务中的代码，输出setTimeout

最后的执行结果如下：

- script start
- async1 start
- async2
- promise1
- script end
- async1 end
- promise2
- setTimeout

```javascript
console.log('start');
setTimeout(() => {
    console.log('children2');
    Promise.resolve().then(() => {
        console.log('children3');
    })
}, 0);

new Promise(function(resolve, reject) {
    console.log('children4');
    setTimeout(function() {
        console.log('children5');
        resolve('children6')
    }, 0)
}).then((res) => {
    console.log('children7');
    setTimeout(() => {
        console.log(res);
    }, 0)
})
```

这段代码中会执行多个宏任务，宏任务中又会有很多微任务

> 1. 从上往下执行代码，先执行同步代码，输出start
> 2. 遇到setTimeout，先把setTimeout的代码放到宏任务队列1中
> 3. 接着往下执行，输出children4，然后把setTimeout的代码放到宏任务队列2中
> 4. 代码执行完成以后，会查找微任务队列中的事件，发现并没有，于是开始执行宏任务1，即第一个setTimeout，输出children2，此时会把Promise.resolve().then()放到微任务队列中
> 5. 宏任务1中的代码执行完成后，会检查微任务队列，于是输出children3，然后开始执行宏任务2，即第二个setTimeout，输出children5，此时将then放到微任务队列中
> 6. 宏任务2中代码执行完成后，查找微任务队列，于是输出children7，然后输出children6

最后的执行结果如下：

- start
- children4
- children2
- children3
- children5
- children7
- children6

```javascript
const p = function() {
    return new Promise((resolve, reject) => {
        const p1 = new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve(1)
            }, 0)
            resolve(2)
        })
        p1.then((res) => {
            console.log(res);
        })
        console.log(3);
        resolve(4);
    })
}


p().then((res) => {
    console.log(res);
})
console.log('end');
```

> 1. 执行代码，Promise本身是同步的立即执行函数，.then是异步执行函数。遇到setTimeout，先把其放入宏任务队列中，遇到p1.then会先放到微任务队列中，然后输出3
> 2. 然后p().then放到微任务队列中，输出end
> 3. 然后检查微任务，输出p1().then结果2，然后输出p().then结果4
> 4. 由于p1.then()已经执行完毕，因此setTimeout的resolve不起作用了，结束


### 10.1  基本数据类型 引用数据类型 及区别

+ 基本数据类型：数字型，字符串型，null，undefinned，布尔型
+ 引用数据类型：对象（数组，正则，函数）
+ 区别：基本数据类型实际数据放在栈中，而引用数据类型的实际数据放在堆内存中

（栈：自动分配内存空间，由系统自动释放； 堆：动态分配内存空间，大小也不一定会释放）

### 10.2 判断数据类型的方法

#### 

 	在 ECMAScript 规范中，共定义了 7 种数据类型，分为 基本类型 和 引用类型 两大类，如下所示：

> **基本类型**：String、Number、Boolean、Symbol、Undefined、Null 
>
> **引用类型**：Object

​	基本类型也称为简单类型，由于其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈中，即按值访问。

​	引用类型也称为复杂类型，由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此，其值存储在堆(heap)中，而存储在变量处的	值，是一个指针，指向存储对象的内存处，即按址访问。引用类型除 Object 外，还包括 Function 、Array、RegExp、Date 等等。

​	鉴于 ECMAScript 是松散类型的，因此需要有一种手段来检测给定变量的数据类型。对于这个问题，JavaScript 也提供了多种方法，但遗憾的是，不同的方法得到的结果参差不齐。

​	下面介绍常用的4种方法，并对各个方法存在的问题进行简单的分析。

+ **1、typeof**

typeof 是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型。返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 7 种：number、boolean、symbol、string、object、undefined、function 等。

```
typeof``''``;``// string 有效``typeof``1;``// number 有效``typeof``Symbol();``// symbol 有效``typeof``true``;``//boolean 有效``typeof``undefined;``//undefined 有效``typeof``null``;``//object 无效``typeof``[] ;``//object 无效``typeof``new``Function();``// function 有效``typeof``new``Date();``//object 无效``typeof``new``RegExp();``//object 无效
```

有些时候，typeof 操作符会返回一些令人迷惑但技术上却正确的值：

- 对于基本类型，除 null 以外，均可以返回正确的结果。
- 对于引用类型，除 function 以外，一律返回 object 类型。
- 对于 null ，返回 object 类型。
- 对于 function 返回  function 类型。

其中，null 有属于自己的数据类型 Null ， 引用类型中的 数组、日期、正则 也都有属于自己的具体类型，而 typeof 对于这些类型的处理，只返回了处于其原型链最顶端的 Object 类型，没有错，但不是我们想要的结果。

+ **2、instanceof**

instanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。 在这里需要特别注意的是：**instanceof 检测的是原型**，我们用一段伪代码来模拟其内部执行过程：

```
instanceof (A,B) = {``  ``var``L = A.__proto__;``  ``var``R = B.prototype;``  ``if``(L === R) {``    ``// A的内部属性 __proto__ 指向 B 的原型对象``    ``return``true``;``  ``}``  ``return``false``;``}
```

从上述过程可以看出，当 A 的 __proto__ 指向 B 的 prototype 时，就认为 A 就是 B 的实例，我们再来看几个例子：

```
[] instanceof Array;``// true``{} instanceof Object;``// true``new``Date() instanceof Date;``// true` `function Person(){};``new``Person() instanceof Person;` `[] instanceof Object;``// true``new``Date() instanceof Object;``// true``new``Person instanceof Object;``// true
```

我们发现，虽然 instanceof 能够判断出 [ ] 是Array的实例，但它认为 [ ] 也是Object的实例，为什么呢？

我们来分析一下 [ ]、Array、Object 三者之间的关系：

从 instanceof 能够判断出 [ ].__proto__  指向 Array.prototype，而 Array.prototype.__proto__ 又指向了Object.prototype，最终 Object.prototype.__proto__ 指向了null，标志着原型链的结束。因此，[]、Array、Object 就在内部形成了一条原型链：

![img](https://images2015.cnblogs.com/blog/849589/201601/849589-20160112232510850-2003340583.png)

从原型链可以看出，[] 的 __proto__  直接指向Array.prototype，间接指向 Object.prototype，所以按照 instanceof 的判断规则，[] 就是Object的实例。依次类推，类似的 new Date()、new Person() 也会形成一条对应的原型链 。因此，**instanceof 只能用来判断两个对象是否属于实例关系****， 而不能判断一个对象实例具体属于哪种类型。**

instanceof 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。

```
var``iframe = document.createElement(``'iframe'``);``document.body.appendChild(iframe);``xArray = window.frames[0].Array;``var``arr =``new``xArray(1,2,3);``// [1,2,3]``arr instanceof Array;``// false
```

针对数组的这个问题，ES5 提供了 Array.isArray() 方法 。该方法用以确认某个对象本身是否为 Array 类型，而不区分该对象在哪个环境中创建。

```
if``(Array.isArray(value)){``  ``//对数组执行某些操作``}
```

Array.isArray() 本质上检测的是对象的 [[Class]] 值，[[Class]] 是对象的一个内部属性，里面包含了对象的类型信息，其格式为 [object Xxx] ，Xxx 就是对应的具体类型 。对于数组而言，[[Class]] 的值就是 [object Array] 。

+ **3、constructor**

当一个函数 F被定义时，JS引擎会为F添加 prototype 原型，然后再在 prototype上添加一个 constructor 属性，并让其指向 F 的引用。如下所示：

![img](https://images2015.cnblogs.com/blog/849589/201705/849589-20170508125250566-1896556617.png)

当执行 var f = new F() 时，F 被当成了构造函数，f 是F的实例对象，此时 F 原型上的 constructor 传递到了 f 上，因此 f.constructor == F

![img](https://images2015.cnblogs.com/blog/849589/201705/849589-20170508125714941-1649387639.png)

可以看出，F 利用原型对象上的 constructor 引用了自身，当 F 作为构造函数来创建对象时，原型上的 constructor 就被遗传到了新创建的对象上， 从原型链角度讲，构造函数 F 就是新对象的类型。这样做的意义是，让新对象在诞生以后，就具有可追溯的数据类型。

同样，JavaScript 中的内置对象在内部构建时也是这样做的：

![img](https://images2015.cnblogs.com/blog/849589/201705/849589-20170508131800457-2091987664.png)

**细节问题：**

> \1. null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。
>
> \2. 函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object

![img](https://images2015.cnblogs.com/blog/849589/201705/849589-20170508132757347-1999338357.png)

为什么变成了 Object？

因为 prototype 被重新赋值的是一个 { }， { } 是 new Object() 的字面量，因此 new Object() 会将 Object 原型上的 constructor 传递给 { }，也就是 Object 本身。

因此，为了规范开发，在重写对象原型时一般都需要重新给 constructor 赋值，以保证对象实例的类型不被篡改。

+ **4、toString**

toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。

对于 Object 对象，直接调用 toString() 就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。

```
Object.prototype.toString.call(``''``) ; ``// [object String]``Object.prototype.toString.call(1) ;  ``// [object Number]``Object.prototype.toString.call(``true``) ;``// [object Boolean]``Object.prototype.toString.call(Symbol());``//[object Symbol]``Object.prototype.toString.call(undefined) ;``// [object Undefined]``Object.prototype.toString.call(``null``) ;``// [object Null]``Object.prototype.toString.call(``new``Function()) ;``// [object Function]``Object.prototype.toString.call(``new``Date()) ;``// [object Date]``Object.prototype.toString.call([]) ;``// [object Array]``Object.prototype.toString.call(``new``RegExp()) ;``// [object RegExp]``Object.prototype.toString.call(``new``Error()) ;``// [object Error]``Object.prototype.toString.call(document) ;``// [object HTMLDocument]``Object.prototype.toString.call(window) ;``//[object global] window 是全局对象 global 的引用
```

 

### 11.   微任务

+ 异步任务分为宏任务、微任务
+ 宏任务：整个script，settimeout，setinterval
+ 微任务：promise，process.nextTick
+ 在执行过程中（首先就是执行一个宏任务），碰到宏任务会被放入宏任务队列中，微任务会被放入微任务队列中，主线程执行完毕，先查看微任务队列，执行完进行渲染，再看宏任务队列，进行第二次循环。

### 12.  js数组扁平化

+ toString split map

### 13. set的各种方法

+ 集合
+ 创建:  new Set();     new Set([1,2,3]);
+ 添加：v.add(2)
+ 大小：v.size
+ 删除：v.delete()
+ 是否有某个元素：v.has()
+ 遍历：for of;  forEach

### 14. map的各种方法

+ 创建： new Map()    或传入一个二维数组
+ 添加：v.set( 'hallo' , 100 )
+ 删除：v.delete('hello')
+ 是否有某个元素：v.has('hello')
+ 获取： v.get('value')

### 15.1 Set Map 的区别

+ map是键值对，set是值的集合
+ map一般用于存储数据，set值不能重复，因此可以用于数组去重
+ map可以用get获取对应的值，set 没有get这个方法

### 15.2  forEach map 的区别





### 16.  js数组方法，哪些可以改变数组本身

+ 数组转字符串：arr.toString( );   arr.join(' ');
  + 不改变数组本身
+ 四个方法：arr.push( ); arr.pop( ); arr.unshift( ); arr.shift( );
  + pop,shift 返回被删除的元素，push，unshift 返回新数组长度
  + 他们都会改变原数组
+ 更改元素：arr[index] = n
  + 更改原数组
+ 末尾追加元素：arr[arr.length] = n (相当于push，也会改变数组本身)
+ 删除元素： delete arr[index] 或直接删除数组 ：delete arr
  + 会改变数组本身，删除元素的位置空出来undefined
+ arr.concat( );  arr.slice( ); arr.splice( );
  + arr.concat(arr1, arr2) 或 arr.concat( 'gf', 'hj' ); (不改变原数组)
  + arr.slice( ); 截取，从第几个到第几个，省略第二个表示到最后。（不改变原数组）
  + arr.splice( ); 第一个是从哪里开始，第二个是删除几个，后面的全是添加的元素
    + 返回删除的元素，改变原数组

### 17.  栈，队列，链表（js如何实现）



### 18.  order的理解



### 19.  什么是闭包，哪里用到了闭包（怎么验证不回收）



### 20.1  es6新特性(展开说)



### 20.2  es6字符串特性



### 21.  递归可以转换成迭代吗



### 22.  TS 对比 JS 



### 23.  JS怎么实现类型检查



### 24.  开发PC端页面和移动端页面分别要考虑什么问题



### 25.  如何构造类



### 26.1  事件冒泡和事件代理

### 26.2  阻止事件冒泡两种方式



### 27.  删除一个DOM节点的方法



### 28.  给两个数组，去重，合并



### 29. js实现继承

+ 1. 原型式继承

  function Son() {

  }

  Son.prototype = new Parent();

  Son.prototype.constructor = Son;

  + 把子类的原型对象赋值给父类的实例，此时可以使用父类的属性和方法
  + 特点：由于子实例的属性和方法，都在父类同一个实例上，因此一个子实例修改，其他也会改

+ 2. 构造函数式继承

  function Son(color) {

    Parent.call(this, color);

  }

  + 利用构造函数进行继承，使用Parent.call将子类的this指向父类构造函数，就可以使用父类属性和方法
  + 特点：通过构造函数创造的实例对象，内部属性方法都独立，不会被其他实例影响

+ 3. 组合式继承

  + 是前两种的结合，把不想共享的属性和方法放在父构造函数内部，让子类使用call继承； 
  + 想共享的放在父类原型对象中，通过原型式来继承

+ 4. 寄生式继承

  var son = Object.create(obj);

  + 原型链式每次实例化对象的时候，都要调用一次父类构造函数
  + 是原型链式继承的改良版，他不需要构造函数，而且实现了属性的共享，

+ 5. 寄生组合式继承

  + 是组合式继承的改良版

  + 把不想共享的属性和方法放在父构造函数内部，让子类使用call继承；想共享的放在父类原型对象中，通过Object.create来继承

  Son.prototype = Object.create(Parent.prototype);

### 30. 浅拷贝与深拷贝（待补充）

+ 所谓拷贝，就是赋值。把一个变量赋给另外一个变量，就是把变量的内容进行拷贝。把一个对象的值赋给另外一个对象，就是把一个对象拷贝一份。

+ 对于基本数据类型来说，直接复制就可以，也就是所说的浅拷贝

+ 对于引用数据类型来说，由于存的是地址，直接浅拷贝，拷贝下来的是地址，不是数据，一个发生变化，其余也要变，也就是说，拷贝的深度不贵，因此需要深拷贝

+ ​    function deepCopy(newObj, oldObj) {

  ​      for (var k in oldObj) {

  ​        var item = oldObj[k];

  ​        if (item instanceof Array) {

  ​          newObj[k] = [];

  ​          deepCopy(newObj[k], item);

  ​        } else if (item instanceof Object) {

  ​          newObj[k] = {};

  ​          deepCopy(newObj[k], item);

  ​        } else {

  ​          newObj[k] = item;

  ​        }

  ​      }

  ​    }

### 31. settimeout怎么工作的，如果时间为零怎么办

+ settimeout 是异步任务，在碰到时，会被放入event table 中，等到了时间再推入事件队列中，当主线程执行完毕，空闲时，会执行事件队列中的settimeout
+ setinterval 也是异步任务，时间到了就推入事件队列，，再过这么长时间再推入，一直推。

### 32.1 let const var

+ var:
  + 声明的范围是函数作用域（函数调用结束后会销毁）
  + 存在变量提升
  + 可以反复声明

+ let:
  + 声明范围块级作用域
  + 不存在变量提升，有暂时性死区
  + 不可以反复声明

+ const:
  + 与let一样，不过声明时必须赋值，并且不能修改他的
  +  如果const是对象，可以修改对象内的属性

### 32.2  ES5怎么实现let,const

### 33. forEach()、map()、filter()、reduce()的用法

##### 1.forEach()

+ forEach方法循环数组中每一个元素并采取操作，没有返回值。它接受一个函数作为参数，这个函数接受三个参数：当前值、当前位置、整个数组。

```
let arr = [1, 2, 3];
arr.forEach(function( item, index, array){
    console.log(item+1, index)
})
//2 0
//3 1
//4 2
```

##### 2.map()

+ map方法遍历数组中每一个元素，有返回值，返回值是每一次执行的结果组成的新数组。不会改变原数组

+ map方法也是接受一个函数作为参数，这个函数接受三个参数：当前值、当前位置、整个数组。

```
let arr = [1, 2, 3];
let newArr = arr.map(function(item, index, array){
   return item*2; 
})
console.log(newArr)  //[2, 4, 6]
console.log(arr)  //[1, 2, 3]
```

##### 3.filter()

+ filter方法过滤数组成员，满足条件的成员组成一个新数组返回。filter也不会改变原数组。

```
let arr = [1, 2, 3, 4, 5];
let newArr = arr.filter(function(item, index, array){
        return item > 3
})
console.log(newArr, arr) //[4, 5], [1, 2, 3, 4, 5]
```

+ 由于map、filter的返回值是数组，因此也可以链式使用。

```
let arr = [1, 2, 3, 4];
let newArr = arr.map(function(item){
   return item*2 
}).filter(function(item){
   return item >= 6 
})
console.log(newArr)  //[6, 8]
```

##### 4.reduce()

+ reduce依次处理数组的成员，最终累计为一个值。

```
let arr = [1, 2, 3, 4, 5];
let newArr = arr.reduce(function(a, b){
  console.log(a, b);
  return a + b;  
}
console.log(arr)  //[1, 2, 3, 4, 5]
console.log(newArr)
// 1 2
// 3 3
// 6 4
// 10 5
//最后结果：15
```

+ 上面代码中 ，reduce方法求出数组所有成员的和。第一次执行，a、b分别是数组中的第一个成员1和第二个成员2。第二次执行，a为上一轮的返回值3，b为数组的第三个成员3。第三次执行，a为上一轮的返回值6，b为数组的第四个成员4。第四次执行，a为上轮的返回值10，b为数组的第五个成员5。至此所有成员遍历完成，整个方法的返回值就是最后一轮的返回值15。

### 34. 数组常用方法（哪些改变原数组）

+ 转字符串：arr.toString( );   arr.join(' ');
  + 不改变数组本身
+ 四个方法：arr.push( ); arr.pop( ); arr.unshift( ); arr.shift( );
  + pop,shift 返回被删除的元素，push，unshift 返回新数组长度
  + 他们都会改变原数组
+ 更改元素：arr[index] = n
  + 更改原数组
+ 末尾追加元素：arr[arr.length] = n (相当于push，也会改变数组本身)
+ 删除元素： delete arr[index] 或直接删除数组 ：delete arr
  + 会改变数组本身，删除元素的位置空出来undefined
+ arr.concat( );  arr.slice( ); arr.splice( );
  + arr.concat(arr1, arr2) 或 arr.concat( 'gf', 'hj' ); (不改变原数组)
  + arr.slice( ); 截取，从第几个到第几个，省略第二个表示到最后。（不改变原数组）
  + arr.splice( ); 第一个是从哪里开始，第二个是删除几个，后面的全是添加的元素
    + 返回删除的元素，改变原数组

### 35. 暂时性死区

+ 只要块级作用域内 存在let命令，它所声明的变量就会“绑定”这个区域，不在受外部的影响。

  如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成封闭作用域。

  凡是在声明之前就使用这些变量，就会报错。 这就是暂时性死区

### 36. 作用域

> 任何程序设计语言都有作用域的概念，简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。
> 换句话说作用域决定了代码区块中变量和其他资源的可见性

让我们先来看个例子

```js
function fn() {
	var variable = "内部变量";
}
fn();//先执行函数
console.log(variable);//报错 variable is not defined
```

![img](https://pic2.zhimg.com/80/v2-c2de0c4967ac76936ff959e7d20af6e9_720w.png)

这里我们就可以看出作用域的概念，变量 variable 在函数 fn 内部声明，全局作用域没有声明，所以在全局作用域下访问 variable 会报错。

我们也可以这样理解：**作用域就是一个独立的区域，让变量不在泄露出去。它最大的作用就是隔离变量，使其不会受到污染**

在JavaScript中，变量的作用域有**全局作用域和局部作用域**两种。

```js
var a=20;
function fn(){
    var sum=0;
    alert(a);//20   局部访问全局
}
fn()//先执行
alert(sum)//报错  全局访问局部
```

![img](https://pic2.zhimg.com/v2-c0c158e23f5134fef2d319d6e8de743d_b.jpg)

上面这个例子我们可以看到**作用域的特点：局部可以访问全局的变量，但全局不能访问局部的变量**

+ 1、全局作用域

  全局作用域在任何地方都可以进行访问，函数的外面叫做全局作用域（不包括函数嵌套）

  在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域：

**（1）最外层函数和在最外层函数外面定义的变量拥有全局作用域，例如：**

```js
var sum = "全局变量"; //最外层变量
function fn() { //最外层函数
    var num = "局部变量";
    function Fun() { //内层函数
        alert('内层访问全局 '+ sum);
    }
    Fun();
}
alert('外层访问全局 ' + sum); //我是最外层变量
fn(); //内层变量
alert('外层访问局部 ' + num); //num is not defined
Fun(); //Fun is not defined
```

![img](https://pic4.zhimg.com/v2-2257939521326abab8b3038f3f870847_b.jpg)

**（2）所有末定义直接赋值的变量自动声明为拥有全局作用域，例如：**

```js
function outFun2() {
    num = "未定义直接赋值的变量";
    var sun = "局部变量";
}
outFun2();//先执行函数
alert(num); //未定义直接赋值的变量
alert(sun); //sun is not defined
```

![img](https://pic4.zhimg.com/v2-d18905e80a87f483b896cc4dbe1ded37_b.jpg)

**（3）所有window对象的属性拥有全局作用域**

​	一般情况下，window对象的内置属性都拥有全局作用域，例如window.name、window.location、window.top等等。

**全局作用域有个严重的弊端**：如果我们写了很多行 JS 代码，变量定义都定义在全局作用域中。这样就会 污染全局命名空间, 容易引起命名冲突。**造成变量污染**

```js
// a 写的代码
var num = 12;

// b 写的代码
var num = 10;

alert(num)// 10
```

+ 2、局部作用域

  局部作用域又叫做函数作用域，是指声明在函数内部的变量。和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部。

```js
function fn(){
    var num="局部变量";
    function Fun(){
        alert('内层访问局部 ' + num);//局部访问局部
    }
    Fun();
}
fn()
alert('外层访问局部 ' + num)
```

![img](https://pic2.zhimg.com/v2-e8caceb3814007117b79f8e5adac2339_b.jpg)

**总结：**

> 作用域特点：局部可以访问全局的变量，但全局不能访问局部的变量
> 全局作用域：在任何地方都可以进行访问，函数的外面叫做全局作用域（不包括函数嵌套）
> 局部作用域：函数内部的变量，只能在局部访问

### 37.  原型，原型链

### 38.  数组去重

### 39.  垃圾回收机制

### 40.  symbol特性

### 41.  可迭代接口怎么实现的

### 42.  ES6后，除了可迭代接口还出现了什么接口

### 43.  事件流event.target 和 event.currenttarget

### 44.1  js能表示的最大安全整数是多少？为什么？

### 44.2  浮点数在计算机内部怎么表示的

### 45.  call apply bind 区别

### 46.  进程，线程

## Vue（ + http)

### 1.  Vue 2.0 Vue 3.0 区别



### 2.1  Vue生命周期

+ 首先new 一个Vue组件

+ 初始化事件和生命周期函数

+ + beforeCreate 准备创建props，data，methods，但是现在还不能用（可以进行loading事件）

+ 初始化props，data，methods

+ + created 已经创建props，data，methods，但是组件模板结构尚未生成（在这个阶段可以发起AJAX请求）

+ 接下来的几步就是根据数据和模板，在内存中编译生成HTML结构

  （1 . 是否有el , 若没有看是否有$mount(el), 

   	2.  是否有template.  有就编译template中的HTML，没有就编译el指向的HTML结构）

+ + beforeMount 将要把内存中编译好的HTML结构渲染到浏览器中

+ 用内存中生成的HTML结构替换el 指向的DOM结构

+ + mounted 已经把内存中生成的HTML结构渲染到浏览器中（可以发起**后端**请求，拿回数据）

+ 当数据发生变化时

+ + beforeUpdated 将要根据变化后最新的数据重新渲染模板结构

+ 根据变化后最新的数据重新渲染模板结构

+ + updated 完成了重新渲染模板结构

+ 要进行销毁时

+ + beforeDestory 即将销毁组件

+ 准备销毁数据侦听器，子组件，事件监听

+ + destoryed 已经完全销毁DOM结构

### 2.2 父子组件生命周期

- 执行顺序：

- - 父组件开始执行到beforeMount 然后开始子组件执行，最后是父组件mounted。
  - 如果有兄弟组件，父组件开始执行到beforeMount，然后兄弟组件依次执行到beforeMount，然后按照顺序执行mounted，最后执行父组件的mounted。

- 当子组件挂载完成后，父组件才会挂载。

- 当子组件完成挂载后，父组件会主动执行一次beforeUpdate/updated钩子函数（仅首次）

- 父子组件在data变化中是分别监控的，但是更新props中的数据是关联的。

- 销毁父组件时，先将子组件销毁后才会销毁父组件。

- 兄弟组件的初始化（mounted之前）是分开进行，挂载是从上到下依次进行

- 当没有数据关联时，兄弟组件之间的更新和销毁是互不关联的

- ***\*Vue 的父组件和子组件生命周期钩子执行顺序？\****

  核心答案：

  第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子。

  **渲染过程：**

  父组件挂载完成一定是等子组件都挂载完成后，才算是父组件挂载完，所以父组件的mounted在子组件mouted之后

  父beforeCreate -> 父created -> 父beforeMount -> 子beforeCreate -> 子created -> 子beforeMount -> 子mounted -> 父mounted

  **子组件更新过程：**

  影响到父组件：父beforeUpdate -> 子beforeUpdate->子updated -> 父updted

  不影响父组件：子beforeUpdate -> 子updated

  **父组件更新过程：**

  影响到子组件：父beforeUpdate -> 子beforeUpdate->子updated -> 父updted

  不影响子组件：父beforeUpdate -> 父updated

  **销毁过程：**

  父beforeDestroy -> 子beforeDestroy -> 子destroyed -> 父destroyed

  重要：父组件等待子组件完成后，才会执行自己对应完成的钩子。

### 3.  watch computed methods区别

+ 三者区别
  + watch
    + 一个对象，键是需要观察的表达式，值是对应回调函数。       
    + 主要用来监听某些特定数据的变化，一个数据影响多个数据。      
    + 可以看作是computed和methods的结合体。
  + computed
    + 属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。          
    + 计算属性，一个数据受多个数据影响。
  + methods
    + 方法表示一个具体的操作，主要是书写业务逻辑。
+ watch 用途
  + watch属性可以来 监听data属性中的数据变化。
  + watch属性还可以来监听function中使用参数来获取新值(newValue)和旧值(oldValue)。
  + watch属性还可以用来监听路由router的变化，只是这里的监听元素是固定的。
+ computed 用途
  + computed也可以监听属性的变化，只是它会根据他的依赖属性生成一个属性，从而影响这个属性的变化。

### 4.  v-if v-for 区别

+ 当它们处于同一节点，`v-for` 的优先级比 `v-if` 更高，这意味着 `v-if` 将分别重复运行于每个 `v-for` 循环中。（Vue2.0，Vue3.0相反）

### 4.2 v-if v-show 区别

+ `v-if` 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。是通过控制DOM节点存在来控制元素显隐。

+ `v-if` 也是**惰性的**：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。

+ 相比之下，`v-show` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。

+ 一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。

### 5.1  Vue父子组件之间如何传值



### 5.2  兄弟组件的通信方式



### 6.1  讲讲单页面应用和多页面应用

+ 引用百度百科：



![img](https:////upload-images.jianshu.io/upload_images/14591403-1169e29a4ebc5d0a.png?imageMogr2/auto-orient/strip|imageView2/2/w/832/format/webp)



**单页面应用的优缺点：**

+ 优点：
  1、用户操作体验好，用户不用刷新页面，整个交互过程都是通过Ajax来操作。
  2、适合前后端分离开发，服务端提供http接口，前端请求http接口获取数据，使用JS进行客户端渲染。

+ 缺点：
  1、首页加载慢
        单页面应用会将js、 css打包成一个文件，在加载页面显示的时候加载打包文件，如果打包文件较大或者网速慢则用户体验不好
  2、SEO不友好
        SEO（Search Engine Optimization）为搜索引擎优化。它是一种利用搜索引擎的搜索规则来提高网站在搜索引擎排名的方法。目前各家搜索引擎对JS支持不好，所以使用单页面应用将大大减少搜索引擎对网站的收录。

![img](https:////upload-images.jianshu.io/upload_images/14591403-4b68ae4490da72c4.png?imageMogr2/auto-orient/strip|imageView2/2/w/708/format/webp)



**为什么页面切换快？**

+ 页面每次切换跳转时，并不需要做`html`文件的请求，这样就节约了很多`http`发送时延，我们在切换页面的时候速度很快。

+ 缺点：首屏时间慢，SEO差

+ 单页应用的首屏时间慢，首屏时需要请求一次`html`，同时还要发送一次`js`请求，两次请求回来了，首屏才会展示出来。相对于多页应用，首屏时间慢。
  SEO效果差，因为搜索引擎只认识`html`里的内容，不认识`js`的内容，而单页应用的内容都是靠`js`渲染生成出来的，搜索引擎不识别这部分内容，也就不会给一个好的排名，会导致单页应用做出来的网页在百度和谷歌上的排名差。

##### 有这些缺点，为什么还要使用Vue呢？

+ `Vue`还提供了一些其它的技术来解决这些缺点，比如说服务器端渲染技术([我是SSR](https://cn.vuejs.org/v2/guide/ssr.html))，通过这些技术可以完美解决这些缺点，解决完这些问题，实际上单页面应用对于前端来说是非常完美的页面开发解决方案。

| mm                         | 多页应用模式MPA                                          | 单页应用模式SPA                                              |
| -------------------------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| 应用构成                   | 由多个完整页面构成                                       | 一个外壳页面和多个页面片段构成                               |
| 跳转方式                   | 页面之间的跳转是从一个页面跳转到另一个页面               | 页面片段之间的跳转是把一个页面片段删除或隐藏，加载另一个页面片段并显示出来。这是片段之间的模拟跳转，并没有开壳页面 |
| 跳转后公共资源是否重新加载 | 是                                                       | 否                                                           |
| URL模式                    | `http://xxx/page1.html 和 http://xxx/page2.html`         | `http://xxx/shell.html#page1 和 http://xxx/shell.html#page2` |
| 用户体验                   | 页面间切换加载慢，不流畅，用户体验差，特别是在移动设备上 | 页面片段间的切换快，用户体验好，包括在移动设备上             |
| 能否实现转场动画           | 无法实现                                                 | 容易实现（手机`app`动效）                                    |
| 页面间传递数据             | 依赖`URL、cookie`或者`localstorage`，实现麻烦            | 因为在一个页面内，页面间传递数据很容易实现(这里是我补充，父子之间传值，或`vuex`或`storage`之类) |
| 搜索引擎优化（SEO）        | 可以直接做                                               | 需要单独方案做，有点麻烦                                     |
| 特别适用的范围             | 需要对搜索引擎友好的网站                                 | 对体验要求高的应用，特别是移动应用                           |
| 搜索引擎优化（SEO）        | 可以直接做                                               | 需要单独方案做，有点麻烦                                     |
| 开发难度                   | 低一些，框架选择容易                                     | 高一些，需要专门的框架来降低这种模式的开发难度               |



### 6.2  单页面性能优化

+ **1） 加载优化**
      在SPA中，通常一开始就会加载所有必需的代码（HTML，JavaScript和CSS），有时候考虑到首屏加载太慢会按需加载，按需加载就是按照当前呈现的不同页面加载不同的文件，而不是最开始就把所有文件都加载出来，从而避免首屏加载很慢。
      当首屏加载完毕后，设备&网络处于空闲状态，可以对其他路由组件进行预加载，以便提升页面切换性能。
      根据路由拆分减少初始加载体积,利用异步加载方式，在路由注册时提供异步拉取组件的方法，仅在需要进入对应路由时，对应组件才会被加载进来。 

- 初次加载的速度

​        单页应用的第一页加载会比基于服务器的应用慢。这是因为首次加载必须先拿到框架和应用程序的代码，再在浏览器中呈现所需的视图。基于服务器的应用程序只需将所需的HTML推送到浏览器，从而减少了延迟和下载用时。

- 加快页面加载速度

​         有一些方法可以加快单页应用的初次加载速度，比如采用多项缓存措施、需要时再加载某些模块（懒加载）。

- 页面生命周期

​        单页应用在初始页面加载时被完全加载，然后页面区域被替换或更新为按需从服务器加载的新页面片段。为避免过度下载未使用的功能，单页应用通常会逐渐下载更多内容，如所需要的功能、页面的一小块，或者完整的一页。

![img](https://img-blog.csdnimg.cn/20190109221137217.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncGIxMjM=,size_16,color_FFFFFF,t_70)

**2)   SEO优化**
        由于我们在处理单页应用的时候页面是不刷新的，所以会导致我们的网页记录和内容很难被搜索引擎抓取到。搜索引擎抓取页面首先要遵循http协议，可是#不是协议内的内容。而实际上也是这样，我们没有见过搜索引擎的搜索结果中，哪一条记录可以快速定位到网页内的某个位置的。解决的方法是用 #!号代替#号，因为谷歌会抓取带有#!的URL。（Google规定，如果你希望Ajax生成的内容被浏览引擎读取，那么URL中可以使用"#!"(这种URL在一般页面一般不会产生定位效果)），这样我们可以解决ajax的不被搜索引擎抓取的问题。在vueJs里面，我们可以看到作者就是这样做的。
**3)   前进后退功能优化**
        配置好路由信息，通过记录浏览过的历史路由信息，可以很好的记录或历史查看过的界面，也可以独立写个足迹功能实现。

### 7.   Vue数据流



### 8. Vue双向数据绑定



### 9.  webpack相关(如何优化)



### 10. 怎么提高打包速度，减少打包体积



### 11.  Vue 技术栈



### 12.  说说 promise 的 async  await



### 13.  promise有哪些方法，all  race 方法以及应用场景



### 14.  cookie 和 webstorage区别

+ 特性
  + cookie 由服务器生成，存储在浏览器的，可以设置失效时间
  + localstorage 除非主动删除，否则即使浏览器关闭内容也不会清除
  + sessionstorage 浏览器关闭后数据会自动删除
+ 大小
  + cookie 可以存储大小约为4KB 
  + webstorage 可以存储大小为5MB左右
+ 与服务器
  + cookie 由服务器生成，发送给服务器，会在服务器下一次请求时被携带
  + webstorage 与服务器没有联系
+ 接口
  + cookie 接口原生的不友好，需要程序员自己封装
  + webstorage 原生接口就可以

### 15.  cookie怎么保存到本地的，cookie怎么实现跨域



### 16.  跨域相关问题



### 17.  常见状态码

+ 200： OK
+ 301：永久重定向
+ 302：临时重定向
+ 303：临时重定向，可以使用get获取到新的URL
+ 304：上次请求的网页未修改（可以进行强制刷新）
+ 401：未授权
+ 403：禁止访问
+ 404：找不到资源

### 18.  v-for 中 key 的作用，没有 key 会怎么样

+ 在写v-for的时候必须要加key，作为唯一标识，可以提高渲染性能，防止数据混乱。

### 19.  观察者模式三个类



### 20.1 token session的区别



### 20.2 cookie session 区别



### 21.1  TCP三次握手，为什么有三次握手

### 21.2  四次挥手

### 22.  https 用了对称加密和非对称加密吗？为什么使用对称加密？



### 23.  动态数组在尾部插入一个元素，时间复杂度，空间复杂度



### 24.  数组和链表的区别



### 25.  节流 防抖（防抖中用到了一个很重要的思想）



### 26.  vue  diff算法（以及虚拟DOM变化及处理）



### 27.  vue响应式原理



### 28.  Vue源码解析


### 29.  单例模式



### 30.1  浏览器缓存（什么时候用）（http缓存）

### 30.2 如果后台数据只有一个字母a，先将他删除，再添加一个字母a, 会命中缓存吗？



### 31.  Vue怎么更新组件



### 32.  组件通信方式



### 33.  浏览器请求方式



### 34.  Ajax怎么实现异步通信



### 35.  插槽的使用



### 36.1 如何实现页面跳转，路由跳转怎么实现



### 36.2 路由原理



### 37.  vue 和 js 的关系



### 38.  vue 的原理或特性



### 39.  vue什么组件能实现增删改



### 40.  前端安全  xsrf怎么防御



### 41.  http组成部分



### 42.  响应头部



### 43.  数据结hash



### 44.  vue Router



### 45.  网络协议



### 46.  socket了解吗



### 47.  vue的特点 优点



### 48.  vuex的使用场景(组成等相关)



### 49.  Ajax实现过程，和promise区别



### 50.  http https 区别，http 如何升级到 https



### 51.  前端各种性能提升



### 52. has history 的区别



### 53. TCP UDP 区别

+ TCP和UDP区别

|            | TCP            | UDP        |
| ---------- | -------------- | ---------- |
| 是否连接   | 面向连接       | 面向非连接 |
| 传输可靠性 | 可靠的         | 不可靠的   |
| 应用场合   | 传输大量的数据 | 少量数据   |
| 速度       | 慢             | 快         |

 

+ OSI 和 TCP/IP 模型在传输层定义两种传输协议：TCP（或传输控制协议）和 UDP（或用户数据报协议）。

+ UDP
  + UDP 与 TCP 的主要区别在于 UDP 不一定提供可靠的数据传输。事实上，该协议不能保证数据准确无误地到达目的地。UDP 在许多方面非常有效。当某个程序的目标是尽快地传输尽可能多的信息时（其中任意给定数据的重要性相对较低），可使用 UDP。ICQ 短消息使用 UDP 协议发送消息。许多程序将使用单独的TCP连接和单独的UDP连接。重要的状态信息随可靠的TCP连接发送，而主数据流通过UDP发送。

+ TCP
  + TCP的目的是提供可靠的数据传输，并在相互进行通信的设备或服务之间保持一个虚拟连接。TCP在数据包接收无序、丢失或在交付期间被破坏时，负责数据恢复。它通过为其发送的每个数据包提供一个序号来完成此恢复。记住，较低的网络层会将每个数据包视为一个独立的单元，因此，数据包可以沿完全不同的路径发送，即使它们都是同一消息的组成部分。这种路由与网络层处理分段和重新组装数据包的方式非常相似，只是级别更高而已。
  + 为确保正确地接收数据，TCP要求在目标计算机成功收到数据时发回一个确认（即 ACK）。如果在某个时限内未收到相应的 ACK，将重新传送数据包。如果网络拥塞，这种重新传送将导致发送的数据包重复。但是，接收计算机可使用数据包的序号来确定它是否为重复数据包，并在必要时丢弃它。

+ TCP与UDP的选择
  + 如果比较UDP包和TCP包的结构，很明显UDP包不具备TCP包复杂的可靠性与控制机制。与TCP协议相同，UDP的源端口数和目的端口数也都支持一台主机上的多个应用。一个16位的UDP包包含了一个字节长的头部和数据的长度，校验码域使其可以进行整体校验。（许多应用只支持UDP，如：多媒体数据流，不产生任何额外的数据，即使知道有破坏的包也不进行重发。）
  + 很明显，当数据传输的性能必须让位于数据传输的完整性、可控制性和可靠性时，TCP协议是当然的选择。当强调传输性能而不是传输的完整性时，如：音频和多媒体应用，UDP是最好的选择。在数据传输时间很短，以至于此前的连接过程成为整个流量主体的情况下，UDP也是一个好的选择，如：DNS交换。把SNMP建立在UDP上的部分原因是设计者认为当发生网络阻塞时，UDP较低的开销使其有更好的机会去传送管理数据。TCP丰富的功能有时会导致不可预料的性能低下，但是我们相信在不远的将来，TCP可靠的点对点连接将会用于绝大多数的网络应用。

+ TCP协议和UDP协议特性区别总结：
  + 1. TCP协议在传送数据段的时候要给段标号；UDP协议不
    2. TCP协议可靠；UDP协议不可靠
    3. TCP协议是面向连接；UDP协议采用无连接
    4. TCP协议负载较高，采用虚电路；UDP采用无连接
    5. TCP协议的发送方要确认接收方是否收到数据段（3次握手协议）
    6. TCP协议采用窗口技术和流控制

### 54.  封装组件相关

### 55.1  熟悉哪些设计模式，在哪里用到了vue的设计模式

### 55.2  工厂模式的应用场景

### 55.3  发布订阅者模式和观察者模式的区别



### 56.  如果浏览器不支持 object.definepoperty 如何兼容

### 57.  Ajax 相关内容

### 58.  axios 请求方式的底层

### 59.  fetch 了解吗?浏览器如果不支持 fetch 要怎么用 fetch

### 60.  从输入 url 到页面渲染过程



### 61.  CDN

### 62.  DNS

### 63.  Content-Type 有哪些

### 64.  http 请求报文结构

### 65.  HTTP 和 TCP 关系

### 66.  HTTP TCP 属于哪个层

### 67.  浏览器的缓存机制

### 68.  项目中怎么设置强制缓存

### 69.  this.$nextTick 原理

### 70.  axios,ajax,promise 区别

### 71.  npm git 

## 排序算法

## 二叉树



## 其他（部分面经）

### 1.  职业规划（3-5年）



### 2.  为什么选择前端



### 3.  如何接触前端



### 5.web 端如果要实现按钮事件的绑定是怎么做? onclick addEventListener

### 6. addEventListener有几个参数?响应的含义? 三个 :事件名 函数 捕获还是冒泡阶段

### 7.addEventListener有兼容性的问题吗?那IE响应的是什么方法 ? attachEvent

### 8.如果有1000个按钮,给它们添加点击事件 你会怎么做? 事件委托

### 9.那你用事件委托在点击时是怎么获取到点击对象的呢?event.target 有兼容性问题吗? (只知道有) 那对应的是什么? ev.target || ev.srcElement

### 

### 11.js原生创建一个标签怎么做? .... appendchild是谁调用?

### 13.那如果现在要加100个新标签,怎么做? 一个个加有性能问题吗?

### 14.为什么有性能问题呢?

### 15.重排具体是怎么做的? 只知道需要重新计算元素在页面中的位置信息,重新构建渲染树,其他的就不知道了

### 16.两个元素互换位置怎么实现? 拖拽 那原生js怎么实现? 删除元素用什么?

### 17.js 添加class类名的方法? jQuery呢

### 18.数组常用的方法?push 的返回值? 改变数组本身的方法?

### 19. Set对象? 遍历方法? 怎么转换成数组? Array.from有几个参数?

### 20.用 Array.from创建一个含有5个undefined的数组

### 22.Map和object 的区别?

### 23.跨域问题 ?cors 具体的设置

### 24.post和get的区别?get 能不能在body传参数?get的大小限制是浏览器的限制还是http协议的限制?

### 25.fetch用过吗?浏览器如果不支持fetch 要怎么用fetch

### 26.ajax能上传文件吗?怎么上传?

### 27.状态码 304 ?和200的区别?强缓存呢?expires和cache-control哪个优先级高?不缓存怎么设置

### 

### 29.grid布局了解吗? 

### 30.移动端了解吗?不怎么了解 移动端的兼容问题(说了不了解了,还是继续问) 不了解

### 32.现在使用es6 vue 兼容怎么解决的



### 1. vuex介绍一些?为什么要commit改变状态

### 2. http中是每一次发送请求就要建立连接吗?(长链接)

### 3. 怎么理解http无状态

### 4. 怎么记录登录状态? cookie 和token有什么区别?

### 5. 发送请求的都带cookie吗

### 6. http 与 https 详细讲加密过程? 证书的验证是什么过程?

### 7. 一个类似word分级标题的数据,你希望后端以什么格式给你?

### 8. 那如果后端给的是一个扁平的,你怎么描述树状关系?

### 9. 自己写一个组件,在程序出错的时候用,你会怎么设计?
