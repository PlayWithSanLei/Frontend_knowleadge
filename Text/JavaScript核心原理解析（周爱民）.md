# JavaScript核心原理解析（周爱民）

## 开篇词｜如何解决语言问题

你好，我是周爱民，和你一样，我喜欢 JavaScript。

我是《JavaScript 语言精髓与编程实践》这本书的作者，这个书名正好也刻画了我追随 JavaScript 的轨迹：在过去的二十年中，我一面研究它的语言精髓，一面做编程实践。

曾经在很长的时间里面，我的脑海中时常会有一个闪念：如何解决语言问题？这也伴随着强烈的自我否定与质疑，因为它的潜台词是：我还没有搞定语言问题。

**问对问题**

在那之前，我是从 DBASE 这个数据库入手，从类似 SQL 的语言开始学习的。第一门正式学习的语言是汇编，然后是 Basic 和 Pascal。后来在商用产品开发的环境中，我选择了 Delphi 这门语言。这一段语言学习的经历，直到 2003 年前后戛然而止，那时我写完了我的第一本书，名字就叫《Delphi 源代码分析》。

这些是我既有的语言知识，一定程度上来说，它限制了我对 JavaScript 的进一步学习，既成习惯的思维方式和知识体系盘根错节，渗透极深。

我是从 1998 年左右就开始接触 JavaScript 这门语言的，然而直到五六年之后，我仍然在使用 Delphi 中的面向对象概念与理论来理解与分析 JavaScript 的对象模型。这也是我早期做 WEUI 这个项目时的困扰：**我一面努力改造着 JavaScript 这门语言，一面又被它所左右。**

那个时代，有太多人做着与我相似的事情：要上线一个大的前端产品，就先写一个框架或库，将传统语言中的经验复制过来。那些是我们的既得财富，闪烁着记忆的光芒、知识的火花，是自我价值和薪资的体现，所以它们是不可抛弃的、不可否认的、不可亵渎的。

在类似于此的、固化的思维里面，我们勤劳地、不知疲倦地写着新代码，而究其原因，只是我们不愿意丢弃那些旧代码而已。

如此负重前行，以至于让我不得不怀疑，自己是否还有能力掌握这门“世界上最被误解的语言”。这是 Douglas Crockford（就是创建了 JSON 格式那位大牛）在 2001 年说过的话。

![img](https://static001.geekbang.org/resource/image/a7/ca/a7314875afe34589031d8d183ddb8fca.jpg)

我真正下定决心抛弃所有，来重新理解这门语言的时候，是在我写出《Delphi 源代码分析》之后不久。这个时候，Borland 破产了，Delphi 被卖掉了，而我也做了架构师。此时，那些既有的经验，以及对语言孰优孰劣的固执己见都变得可有可无了。这时，对于我一直以来的困惑，我才真正地问对了第一个问题：

**JavaScript 到底是一门什么样的语言？**

**语言**

我常常说，问对了问题，也就有了“解”。

在 JavaScript 诞生的时候，主流的应用开发语言大多是静态的，以及单一语言类型的。当时面向对象编程大行其道，众多语言都纷纷以“我最 OOP”为宣传噱头，以及将它想像成语言发展的必然方向。随着 Java/JVM 的成熟，使用中间指令集 + 虚拟机来运行的语言环境也变得流行起来，因此一个虚拟机上跑很多种语言也就成了常态。但即使如此，具体到每一种语言，其主要特性还是单一的，并且通常以保持“语言特性的纯净”为己任。

JavaScript 却是一个异类，它最开始是一门“简单”的小语言，没有丰富的语言特性，也没有大一统的野心，更没有“包打天下”的虚拟机引擎。为了维护这种“小而简洁”，当然，另一部分原因也在于它的创始者太过匆忙和随意——它只实现了一些基础的语言特性，而没有从根本上“陈述”自己的设计原则与理念。

这门语言非常摇摆，在面向对象火的时候，它说“我是 OOP 的语言”；在函数式语言呼声渐高的时候，它又说“我是函数式的”。另外，你知道的，它天生还是一门动态的语言。不过，它也还包括一些静态的、结构化的语言成分。

支持这门语言挣扎求生、一路行来的，正是这门语言最初的、最精彩的设计：它是一门多范型语言，或者，也称为混合范型语言。JavaScript 的简单来自于此，复杂也来自于此；生存能力来自于此，抨击诟病也来自于此。

的确，如果我不抛开 Delphi 语言给我留下的历史包袱，我还是能从 JavaScript 中看到我熟悉的、引以为傲的经验闪光，并让这些东西迅速激活我对语言的兴趣和掌控感。然而只需要稍稍多一点点时间，混合语言中的其它组分就会变成我的困扰，变成这门语言给我带来的种种陷阱，变成我近乎绝望的自我怀疑。

而其实问题的求解也很简单：**不要试图去纯化这门语言。**

**语言的特性**

所以在这个专栏里面，我就想与你讲一讲我对 JavaScript 各种语言特性的理解，还有展示将这些语言特性和语言范型融合如一的具体挑战与折衷。

JavaScript 主要包括 5 个方面的语言特性：结构化编程、面向对象编程、动态语言、函数式语言和并行语言。因此在这个专栏中，我将以“语言”为核心，主要讨论语言设计，结构化和面向对象特性，以及部分的动态语言特性。还有一些其它部分的特性，我将会在以后的专栏中再给你讲。

在讲述的内容方面，尽管每一讲都是一个独立的标题，但总体来说，这些内容也是循序渐进的，因此你最好不要落下课程。并且如果有时间、有机会的话，还是对前面的内容做一些分析和巩固为好。

另外，你可能已经注意到了：每一讲的标题都是一行代码。尽管这些代码绝大多数都是有意义的、可以使用的，但是我并不是从实用性出发来写出这些代码的，因此它们不见得能很好地使用在你的项目中。我尽量使每一讲的标题在表达多种语言特性的同时，指向一个主要的、核心的内容讲述方向。

事实上，如果你看到那样的一行标题后，能猜出它涉及到哪些混合语言特性，或者是由哪些特性共同作用以导致这个代码的形式风格或可能的结果，那么你也就相当于复盘了你的知识储备，这有助于你建立自己的知识体系。

所以，你大可以将这样的标题当作一把念珠，没事的时候，盘一盘。：）

**体系性**

说到体系性，其实这才是我这个课程最关注的地方。

我希望综合这些代码的特殊性，代码所涉问题的领域，代码的逐步分解解析，以及辨析与该代码相似的或同类的问题，一方面发掘它们潜在的应用，另一方面，则在于帮助你构建一个语言知识结构。这样的语言知识结构，能让你看到曾经摸过的那些项目，写过的那些代码，填过的那些巨坑的影子，并且发掘暗影背后涌动的语言原力，找到属于自己的、可规划的语言学习体系。

你不需要精通所有的语言，但如果你了解那些语言类型的核心的、本质的差异，建立起自己的对语言的认识观和辨析力，那么当你接触到一门新的语言时，便可以在极快的时间内将它纳入自己的语言知识结构，快速地映射到那些历史项目和研发经验中。你可以通过想象，将新的语言在自己的经验中“回放一遍”，这相当于用新语言重写了一遍那些代码，也相当于将你自己的历史经验全部消化在这个新语言之中。

这样的语言学习和感悟方法，收效是极快的。

我曾经在豌豆荚的工作中，完成过一个用 Lua 来实现的、支持大规模并发的服务端项目，那是一个金融级的风控产品。在我对 Lua 了解几乎为零的情况下，出于对“编程语言核心原理”的了解，通过上述知识映射的方法，我在零学习的情况就开始了编码工作。除了必要的查手册之外，切换语言的时间成本几乎可以忽略不计。

当然，听到这里的时候，你可能会说“Lua 和 JavaScript 的相似性太高”，又或者说“Lua 太简单了”。但是事实上，我之前在学习 Erlang 的时候也是如此，以及后来在学习 Scala 的时候仍然是如此。当你真正地“解决了语言问题”时，“新语言”真的对你来说完全不能称其为问题。

所谓的语言特性，其实是对语言的核心抽象概念的语法表现。所以，所谓的“学习新语言”，只不过是在玩“变换代码风格”的游戏，而已。

一旦你建立了你的体系性，那么相当于你创建了游戏规则，你就成了“编程游戏”中的上帝。

你将会有一种切实的、万物如一的操控感。

**学这门课**

所以，这门课的内容大概率不会用在你的一个线上项目中，也不会提高你写代码的速度。但它绝对能让你提升对代码的洞察力，让你可以在纷繁的代码中快速找到它在性能、组织、逻辑等问题的关键，也可以在语言层面给出合理的解释。

当然，就一个具体问题的具体解，这一切还是不够的，因为语言是实现业务的工具，而不是业务本身。所以，在面试中不仅仅会考察你的语言能力，也会考察你对曾经项目的经验与感受。

无论如何，我希望你能找到自己对语言的认识，无论是不是通过这门课程，“构造认识”对你自己而言都是极致重要的事情。如果在这其中，我的课程能对你有所帮助，哪怕仅仅是一点点启发，我想，这都是我非常乐意看到的结果了。

最后，多谢你来看我的专栏。关于 JavaScript，你的理解是怎样的呢？你又有什么样的期待？欢迎留言。

## 从零开始：JavaScript语言是如何构建起来的

### 01｜delete 0：JavaScript中到底有什么是可以销毁的

今天是这个系列的第一讲，我将从 JavaScript 中最不起眼的、使用率最低的一个运算——delete 讲起。

你知道，JavaScript 是一门面向对象的语言。它很早就支持了 delete 运算，这是一个元老级的语言特性。但细追究起来，delete 其实是从 JavaScript 1.2 中才开始有的，与它一同出现的，是对象和数组的字面量语法。

有趣的是，JavaScript 中最具恶名的 typeof 运算其实是在 1.1 版本中提供的，比 delete 运算其实还要早。这里提及 typeof 这个声名狼藉的运算符，主要是因为 delete 的操作与类型的识别其实是相关的。

#### **习惯中的“引用”**

早期的 JavaScript 在推广时，仍然采用传统的数据类型的分类方法，也就是说，它宣称自己同时支持值类型和引用类型的数据，并且，所谓值类型中的字符串是按照引用来赋值和传递引用（而不是传递值）的。这些都是当时“开发人员的概念集”中已经有的、容易理解的知识，不需要特别解释。

但是什么是引用类型呢？

在这件事上，JavaScript 偷了个懒，它强行定义了“Object 和 Function 就是引用类型”。这样一来，引用类型和值类型就给开发人员讲清楚了，对象和函数呢，也就可以理解了：它们按引用来传递和使用。

绝大多数情况下，这样解释起来是行得通的。但是到了 delete 运算这里，就不行。

因为这样一来，delete 0就是删除一个值，而delete x就既可能是删除一个值，也可能是删除一个引用。然而，当时 JavaScript 又同时约定：那些在 global 对象上声明的属性，就“等同于”全局变量。于是，这就带来了第三个问题：delete x还可能是删除一个 global 对象上的属性。而它在执行这个操作的时候，看起来却像是一个全局变量（的名字）。

这中间有哪些细节的区别呢？

delete 这个运算的表面意思，是该运算试图销毁某种东西。然而，delete 0中的 0 是一个具体的、字面量表示的“值”。一个字面量值“0”如何在现实世界中销毁呢？假定它销毁了，那是不是说，在这个语言当前的运行环境中，就不能使用 0 这个值了呢？显然，这不合理。

所以，JavaScript 认为“所有删除值的 delete 就直接返回 true”，表明该行为过程中没有异常。很不幸，JavaScript 1.2 的时代并没有结构化异常处理（即 try…catch 语句）。所以，通过函数调用中返回 true 来表明“没有异常”，其实是很常规的做法。

然而，返回值只表明执行过程中没有异常，但实际的执行行为是“什么也没发生”。你显然不可能真的将“0”从执行系统中清理出去。

那么接下来，就还剩下删除变量和删除属性。由于全局变量实际上是通过全局对象的属性来实现的，因此删除变量也就存在识别这两种行为的必要性。例如：

```js
delete x
```

这行代码究竟是在删除什么呢？出于 JavaScript 是动态语言这项特性，从根本上来说，我们是没有办法在语法分析期来判断x的性质的。所以现在，需要有一种方法在运行期来标识x的性质，以便进一步地处理它。

这就导致了一种新的“引用”类型呼之欲出。

#### **到底在删除什么？**

探索工作往往如此，是所谓“进五退一”，甚至是“进五退四”。在今后的专栏文章中，你往往会看到，我在碰触到一种新东西的时候会竭力向前，但随后又后退好几步，再来讨论一些更基础层面的东西。这是因为如果不把这些基础概念说得清楚明白，那么往前冲的那几步常常就被带偏了方向。

一如现在这个问题：**delete 0到底是在删除什么？**

对于一门编译型语言来说，所谓“0”，就是上面所述的一个值，它可以是基础值（Primitive values），也可以是数值类型。但如果将这个问题上升到编译之前的、所谓语法分析的阶段，那么“0”就会被称为一个记号（Tokens）。一个记号是没有语义的，记号既可以是语言能识别的，也可以是语言不能识别的。唯有把这二者同时纳入语言范畴，那么这个语言才能识别所谓的“语法错误”。

delete 不仅仅是要操作 0 或 x 这样的单个记号或标识符（例如变量）。因为这个语法实际起作用的是一个对象的属性，也就是“删除对象的成员”。那么它真正需要的语法其实是：

```js
delete obj.x
```

只不过因为全局对象的成员可以用全局变量的形式来存取，所以它才有了

```js
delete x
```

这样的语法语义而已。所以，这正好将你之前所认识的倒转过来，是删除 x 这个成员，而不是删除 x 这个值。不过终归有一点是没错的：既然没办法表达异常，而 delete 0 又不产生异常，那么它自然就该返回 true。

然而，如果你理解了delete obj.x，那么就一定会想到：obj.x既不是之前说过的引用类型，也不是之前说过的值类型，它与typeof(x)识别的所有类型都无关。因为，它是一个表达式。

所以，delete 这个操作的正式语法设计并不是“删除某个东西”，而是“删除一个表达式的结果”：

```js
delete UnaryExpression
```

#### **表达式的结果是什么？**

在 JavaScript 中表达式是一个很独特的东西，所有一切表达式运算的终极目的都是为了得到一个值，例如字符串。然后再用另外一些操作将这个值输出出来，例如变成网页中的一个元素（element）。这是 JavaScript 语言创生的原力，也是它的基础设计。也只是因为有了这种设计，它才变得既像面向对象的，又像函数式语言的样子。

表达式的执行特性，以及表达式与语句的关系等等细节，回头我放在第二阶段的内容中讲给你听。现在我们只需要关注一个要点，表达式计算的结果到底是什么？因为就像上面所说的，这个结果，才是delete这个操作要删除的东西。

在 JavaScript 中，有两个东西可以被执行并存在执行结果（Result），包括语句和表达式。比如你用eval()来执行一个字符串，那么实际上，你执行的是一个语句，并返回了语句的值；而如果你使用一对括号来强制一个表达式执行，那么这个括号运算得到的，就是这个表达式的值。

表达式的值，在 ECMAScript 的规范中，称为“引用”。

 这是一种称为“规范类型”的东西。

#### **规范中的“引用”**

实际上这个概念出现得也很早。从 JavaScript 1.3 开始，ECMAScript 规范就在语言定义的层面，正式地将上述的天坑补起来，推出了上面说到的这个“（真正的）引用类型”。

但是，由于这个时候规范的影响力在开发人员中并不那么大，所以开发人员还是习惯性地将对象和函数称为引用，而其它类型就称为值，并且继续按照传统的理解来解释 JavaScript 中对数据的处理。

这种情况下，一个引用只是在语法层面上表达“它是对某种语法元素的引用”，而与在执行层面的值处理或引用处理没关系。所以，下面这行简短的语句：

```js
delete 0
```

实际上是在说：JavaScript 将 0 视为一个表达式，并尝试删除它的求值结果。

所以，现在这里的 0，其实不是值（Value）类型的数据，而是一个表达式运算的结果（Result）。而在进一步的删除操作之前，JavaScript 需要检测这个 Result 的类型：

+ 如果它是值，则按照传统的 JavaScript 的约定返回 true；
+ 如果它是一个引用，那么对该引用进行分析，以决定如何操作。

这个检测过程说明，ECMAScript 约定：任何表达式计算的结果（Result）要么是一个值，要么是一个引用。并且需要留意的是，在这个描述中，所谓对象，其实也是值。准确地说，是“非引用类型”。例如：

```js
delete {}
```

那么显然，这里要删除的一对大括号是表示一个字面量的对象，当它被作为表达式执行的时候，结果也是一个值。这也是我常常将所有这类表达式称为“单值表达式”的原因，这里并没有所谓的“引用”。

你可以像下面这样，非常细致而准确地解释这一行代码：单值表达式的运算结果返回那个“对象字面量”的单值。然后，delete运算发现它的操作数是“值 / 非引用类型”，就直接返回了 true。

所以，什么也没有发生。

#### **还会发生什么**

那么到底还会发生什么呢？

在 JavaScript 的内部，所谓“引用”是可以转换为“值”，以便参与值运算的。因为表达式的本质是求值运算，所以引用是不能直接作为最终求值的操作数的。这依赖于一个非常核心的、称为“GetValue()”的内部操作。所谓内部操作，也称为内部抽象操作（internal abstract operations），是 ECMAScript 描述一个符合规范的引擎在具体实现时应当处理的那些行为。

GetValue()是从一个引用中取出值来的行为。这有什么用呢？比如说下面这行代码：

```js
x = x
```

我们上面说过，所谓 x 其实是一个引用。上面的表达式其实是一个赋值表达式，那么“引用 x 赋值给引用 x”有什么意义呢？其实这在语法层面来解释是非常直接的：

> 所有赋值操作的含义，是将右边的“值”，赋给左边用于包含该值的“引用”。

那么上面的x=x，其实就是被翻译成：

```js
x = GetValue(x)
```

来执行的。而 JavaScript 识别两个 x 的不同的方法，就称为“手性”，即是所谓“左手端 (lhs, left hand side)”和“右手端 (rhs)”。它本来是用来描述自然语言的语法中，一个修饰词应该是放在它的主体的前面或是后面的。而在程序设计语言中，它用来说明一个记号（Token）是放在了赋值符号（例如“=”号）的左边或是右边。作为一个简单的结论，区别上例中的两个 x 的方法就是：

> 如果 x 放在左边作为 lhs，那么它是引用；如果放在右边作为 rhs，那么就是值。

所以x=x的语义并不是“x 赋给 x”，而是“把值 x 赋给引用 x”。

所以，“delete x”归根到底，是在删除一个表达式的、引用类型的结果（Result），而不是在删除 x 表达式，或者这个删除表达式的值（Value）。

是的，在 JavaScript 中的delete是一个很罕见的、能直接操作“引用”的语法元素。由于这里的“引用”是在 ECMAScript 规范层面的概念，因此在 JavaScript 语言中能操作它的语法元素其实非常少。

然而很不幸，delete 就是其中之一。

#### **告诉我这些有什么用**

等等，我想你一定会问了：神啊，让我知道这些究竟有什么用呢？我永远也不会去执行delete 0这样的操作啊！

是的。但是我接下来要告诉你的事实是：obj.x也是一个引用。对象属性存取是 JavaScript 的面向对象的基本操作之一，所以本质上我们早就在使用“引用”这个东西了，只不过它太习以为常，所以大家都视而不见。

“属性存取（"."运算符）”返回一个关于“x”的引用，然后它可以作为下一个操作符（例如函数调用运算“()”）的左手端来使用，这才有了著名的“对象方法调用”运算：

```js
obj.x()
```

因为在对象方法调用的时候，函数 _x()_ 是来自于obj.x这个引用的，所以这个引用将obj这个对象传递给 x()，这才会让函数 _x()_ 内部通过 this 来访问到 obj。

根本上来说，如果obj.x只是值，或者它作为右手端，那么它就不能“携带”obj 这个对象，也就完成不了后续的方法调用操作。

> 对象存取 + 函数调用 = 方法调用

这是 JavaScript 通过连续表达式运算来实现新的语义 / 语法的经典示例。

而所谓“连续运算”其实是函数式运算范式的基本原则。也就是说，obj.x()是在 JavaScript 中集合了“引用规范类型操作”“函数式”“面向对象”和“动态语言”等多种特性于一体的一个简单语法。

而它对语言的基础特性的依赖，就在于：

+ delete 0中的这个0是一个表达式求值
+ delete x中的x是一个引用
+ delete obj.x中obj.x是一组表达式连续运算的结果(Result/引用)

于是，我们现在可以解释，当 x 是全局对象 global 的属性时，所谓delete x其实只需要返回global.x这个引用就可以了。而当它不是全局对象 global 的属性时，那么就需要从当前环境中找到一个名为x的引用。找到这两种不同的引用的过程，称为 ResolveBinding；而这两种不同的x，称为不同环境下绑定的标识符 / 名字。

#### **知识回顾**

下一讲我将给你讲述的，就是这个名字从声明到发现的全过程。至于现在，这一讲就要告一段落了。今天的内容中，有一些知识点我来带你回顾一下。

+ delete 运算符尝试删除值数据时，会返回 true，用于表示没有错误（Error）。
+ delete 0 的本质是删除一个表达式的值（Result）。
+ delete x 与上述的区别只在于 Result 是一个引用（Reference）。
+ delete 其实只能删除一种引用，即对象的成员（Property）。

所以，只有在delete x等值于delete obj.x时 delete 才会有执行意义。例如with (obj) ...语句中的 delete x，以及全局属性 global.x。

#### **思考题**

+ delete x中，如果x根本不存在，会发生什么？

  > 返回true
  >
  > x 表达式返回的应该是一个引用，并且环境中并没有表示这个引用不能被删除。但是有一点，这个x的确会得到一个引用，称为（UnresolvableReference）。而这一段逻辑在ECMAScript里面写的是“if IsUnresolvableReference, then return true”。也就是说，ECMAScript约定对于这种情况就是这么返回的，这属于规范约定（并且如果在这时发现是严格模式，就抛异常了）。

+ delete object.x 中，如果x是只读的，会发生什么？

  > 如果x只读，delete object.x不能删除掉x属性，返回false；如果在严格模式下，会报错：TypeError: Cannot delete property 'c'

+ delete undefined 和 delete null分别是什么？

  > 早期的JavaScript中，undefined是一个特殊值，是在运行期中通过void运算，或者不返回值的函数，又或者一个声明了但未赋值的变量，等等类似这样的情况来“计算得到”的。所以在JavaScript的早期版本中，你没有办法直接判断“undefined是undefined”，例如无法写出“x === undefined”这样的代码，而你只能写类似“typeof(x) ==='undefined'”这样的代码。
  >
  > 后来（其实也没有太久），规范就约定把undefined作为可以缺省访问的名字，类似于null。但是这个时候就带来了一个矛盾，因为这个undefined很重要，早期的绝大多数框架或引擎都把它作为一个“全局名字”给声明了。也就是说，ECMAScript现在既没有办法将它规范成一个keyword，也没有办法处理成保留字等等，它看起来像null，但又没有办法在规范层面强制它。所以……ECMAScript就搞了一个“奇招”：
  >
  > >  我们把undefined声明成全局的属性，怎么样？！
  >
  > 嗯嗯，很好。所以你看，现在的引擎上面undefined看起来长得跟null值差不多，而且在ECMAScript规范中它们都还是平级的（是原始值），而且它们的作用也很接近，最后他们都还是从最初的JavaScript 1.x中就存在的概念，但是undefined/null两者却在实现上完全不同：undefined是一个全局属性，而null是一个关键字。
  >
  > 由于undefined是全局属性，所以`delete undefined`其实就是`delete global.undefined`，是删除引用，而不是删除值。而这个属性是只读的，所以就返回false了。
  >
  > 例如你可以试试下面的代码：
  >
  > >  Object.getOwnPropertyDescriptor(global, 'undefined')
  > > { value: undefined,
  > >  writable: false,
  > >  enumerable: false,
  > >  configurable: false }

### 02｜var x = y = 100：声明语句与语法改变了JavaScript的语言核心性质

如果你听过上一讲的内容，心里应该会有一个问题，那就是——在规范中存在的“引用”到底有什么用？它对我们的编程有什么实际的影响呢？

当然，除了已经提及过的delete 0和obj.x之外，在今后的课程中，我还会与你讨论这个“引用”的其它应用场景。而今天的内容，就从标题来看，若是我要说与这个“引用”有关，你说不定得跳起来说我无知；但若说是跟“引用”无关的话呢，我觉得又不能把标题中的这一行代码解释清楚。

为什么这行代码看起来与规范类型中的“引用”无关呢？因为这行代码出现的时候，连 ECMAScript 这个规范都不存在。

我大概是在 JavaScript 1.2 左右的时代就接触到这门语言，在我写的最早的一些代码中就使用过它，并且——没错，你一定知道的：它能执行！

有很多的原因会促使你在 JavaScript 写出表达式连等这样的代码。从 C/C++ 走过来的程序员对这样的一行代码是不会陌生的。它能用，而且结果也与你的预期会一致，例如：

```js
var x = y = 100;
console.log(x); // 100
console.log(y); // 100
```

它既没错、又好用，还很酷，你说我们为什么不用它呢？然而很不幸，**这行代码可能是 JavaScript 中最复杂和最容易错用的表达式了**。

所以今天我要和你一起好好地盘盘它。

#### 声明

至今为止，除标签声明之外，JavaScript 中一共只有六条声明用的语句。注意，所有真正被定义“声明”的语法结构都一定是“语句”，并且都用于声明一个或多个标识符。这里的标识符包括变量、常量等。

严格意义上讲，JavaScript 只有变量和常量两种标识符，六条声明语句中：

+ let _x_...

  声明常量x。不可在赋值之前读。

+ const _x_...

  声明常量x。不可写。

+ var _x_...

  声明变量x。在赋值之前可以读取到undefined值。

+ function _x_...

  声明变量x。该变量指向一个函数。

+ class _x_...

  声明变量x。该变量指向一个类（该类的作用域内部是处理严格模式的）。

+ import _x_...

  导入标识符并作为常量（可以有多种声明标识符的模式和方法）。

除了这六个语句之外，还有两个语句有潜在的声明标识符的能力，不过它们并不是严格意义上的声明语句（声明只是它们的语法效果）。这两个语句是指：

+ for (_var_|_let_|_const_ _x_ …) …

  for 语句有多种语法来声明一个或多个标识符，用作循环变量。

+ try … catch (x) …

  catch 子句可以声明一个或多个标识符，用作异常对象变量。

总的来说，除上述的语法，用户是没有其它方式来在当前的代码上下文中“声明”出一个标识符来的。而我之所以在这里严格强调这一“汇总性的”结果，是因为下面的一个简单论断，所有的“声明”：

> + 都意味着 JavaScript 将可以通过“静态”语法分析发现那些声明的标识符；
> + 标识符对应的变量 / 常量“一定”会在用户代码执行前就已经被创建在作用域中。

这个标题中的var x就是一个声明。在这个声明的后半部分，使用“=”这个符号引导了一个初始化语法——通常情况下可以将它理解为一个赋值运算。

#### **从读取值到赋值**

声明是在语法分析阶段就处理的，并且因此它会使得当前代码上下文在正式执行之前就拥有了被声明的标识符，例如x。

这其实非常有趣，因为这表明**JavaScript 虽然被称为是“动态语言”，但确实是拥有静态语义的。**而在 JavaScript 的早期，这个静态语义其实并没有处理得太好，一个典型的问题就是所谓的“变量提升”。也就是可以在变量声明之前访问该变量。例如：

```js
console.log(x); // undefined
var x = 100;
console.log(x); // 100
```

这个“变量提升”还包括“变量被创建于声明它的语法块”之外的意思，但这并不是这里要讨论的内容，我会在今后再讲它。在今天的课程里，你只需要留意这个变量的读写过程就好了。那么，关于读取值，之前声明的变量与常量又有什么不同呢？

如上面已经说过的，由于标识符是在用户代码执行之前就已经由静态分析得到，并且创建在环境中，因此 let 声明的变量和 var 声明的变量在这一点上没有不同：它们都是在读取一个“已经存在的”标识符名。例如：

```js
var y = "outer";
function f() {
  console.log(y); // undefined
  console.log(x); // throw a Exception
  let x = 100;
  var y = 100;
  ...
}
```

正是由于var y所声明的那个标识符在函数 f() 创建（它自己的闭包）时就已经存在，所以才阻止了console.log(y)访问全局环境中的y。类似的，let x所声明的那个x其实也已经存在 f() 函数的上下文环境中。访问它之所以会抛出异常（Exception），不是因为它不存在，而是因为这个标识符被拒绝访问了。

在 ECMAScript 6 之后出现的let/const变量在“声明（和创建）一个标识符”这件事上，与var并没有什么不同，只是 JavaScript 拒绝访问还没有绑定值的let/const标识符而已。

回到 ECMAScript 6 之前：JavaScript 是允许访问还没有绑定值的var所声明的标识符的。这种标识符后来统一约定称为“变量声明（varDelcs）”，而“let/const”则称为“词法声明（lexicalDecls）”。JavaScript 环境在创建一个“变量名（varName in varDecls）”后，会为它初始化绑定一个 undefined 值，而”词法名字（lexicalNames）”在创建之后就没有这项待遇，所以它们在缺省情况下就是“还没有绑定值”的标识符。

> NOTE：6 种声明语句中的函数是按 varDecls 的规则声明的；类的内部是处于严格模式中，它的名字是按 let 来处理的，而 import 导入的名字则是按 const 的规则来处理的。所以，所有的声明本质上只有三种处理模式：var 变量声明、let 变量声明和 const 常量声明。

所以，标题中的var x = ...在语义上就是为变量 x 绑定一个初值。在具体的语言环境中，它将被实现为一个赋值操作。

#### 赋值

如果是在一门其它的（例如编译型的）语言中，“为变量 x 绑定一个初值”就可能实现为“在创建环境时将变量 x 指向一个特定的初始值”。这通常是静态语言的处理方法，然而，如前面说过的，JavaScript 是门动态的语言，所以它的“绑定初值”的行为是通过动态的执行过程来实现的，也就是赋值操作。

那么请你仔细想想，一个赋值操作在语法上怎么表达呢？例如：

```js
变量名 = 值
```

这样对吗？不对！在 JavaScript 中，这样讲是非常不正确的。正确的说法是：

```js
lRef = rValue
左引用 = 右值
```

也就是将右操作数（的值）赋给左操作数（的引用）。它的严格语法表达是：

> **LeftHandSideExpression** `< = | AssignmentOperator >` **AssignmentExpression**

也就是说，在 JavaScript 中，一个赋值表达式的左边和右边其实“都是”表达式！

#### 向一个不存在的变量赋值

接下来我要给你介绍的是从 JavaScript 1.0 开始就遗留下来的一个巨坑，也就是所谓的“变量泄漏”问题。这在早期的 JavaScript 中的确是一个好用的特性：如果你向一个不存在的变量名赋值，那么 JavaScript 会在全局范围内创建它。

也就是说，代码中不需要显式地声明一个变量了，变量可以随用随声明，也不用像后来的let语句一样，还要考虑在声明语句之前能不能访问的问题了。这非常简单，在少量的代码中也相当易用。

但是，如果代码规模扩大，变成百千万行代码，那么“一个全局变量是在哪里声明和创建的”就变成一个非常要紧的问题。

如果随时都可能泄露一个代码给全局，或者随时都可能因为忘记本地的声明而读写了全局变量，那对调试除错将是一场灾难。另外，晚一些出现的运行期优化技术也不能很好地处理这种情况。所以从 ECMAScript5 开始的严格模式就禁止了这种特性，试图避免用户将变量泄露到全局环境。

然而现实中，即使在严格模式下这种泄露也未能避免。这称为“间接执行”，这将是另一个巨大的议题，并且是 ECMAScript6 之后开始的一种新的机制。但是现在这里发生的事情，也就是这个“向不存在的变量赋值”的问题，是从 JavaScript 1.0 时代就遗留下来的问题，也是 ECMAScript 为 JavaScript 填补的最大设计漏洞之一。

那么，在具体技术细节上，这个变量声明是如何发生的呢？

事实上，这是因为在早期设计中，JavaScript 的全局环境是引擎使用一个称为“全局对象”东西管理起来的。

这个全局对象几乎类似或完全等同于一个普通对象。只不过，JavaScript 引擎将全局的一些缺省对象、运行期环境的原生对象等东西都初始化在这个全局对象的属性中，并使用这个对象创建了一个称为**“全局对象闭包”**的东西，从而得到了 JavaScript 的全局环境。

早期的 JavaScript 的引擎实现非常简洁，许多基础的技术组件都是直接复用的，例如这里的所谓全局环境、全局闭包，或者全局对象的实现方法，就与**“with 语句”**的效果完全相同——他们是相互复用的。

当向一个不存在的变量赋值的时候，由于全局对象的属性表是可以动态添加的，因此 JavaScript 将变量名作为属性名添加给全局对象。而访问所谓全局变量时，就是访问这个全局对象的属性。因此，实际效果就变成了“可以动态地向全局环境中添加一个变量”。并且，显然地，我们在第一讲已经讲过这个结果——你可以删除掉这个动态添加的“变量”，因为本质上就是在删除全局对象的属性。

那么现在（我是指在 ECMAScript6 之后）的 JavaScript 的全局环境有什么不同吗？

为了兼容旧的 JavaScript 语言设计，现在的 JavaScript 环境仍然是通过将全局对象初始化为这样的一个全局闭包来实现的。但是为了得到一个“尽可能”与其它变量环境相似的声明效果（varDecls），ECMAScript 规定在这个全局对象之外再维护一个变量名列表（varNames），所有在静态语法分析期或在 eval() 中使用var声明的变量名就被放在这个列表中。然后约定，这个变量名列表中的变量是“直接声明的变量”，不能使用delete删除。

于是，我们得到了这样的一种结果：

```js
var a = 100;
x = 200

// a 和 x都是global的属性
Object.getOwnPropertyDescriptor(globalThis, 'a');
// { value: 100, writable: true, enumerable: true, configurable: false }
Object.getOwnPropertyDescriptor(globalThis, 'x');
// { value: 200, writable: true, enumerable: true, configurable: true }
// a不能删除，x可以删除
delete a
// false
delete x
// true

a
// 100
x
// VM1239:1 Uncaught ReferenceError: x is not defined
```

所以，表面看起来“泄漏到全局的变量”与使用var声明的都是全局变量，并且都实现为 global 的属性，但事实上它们是不同的。并且当var声明发生在 eval() 中的时候，这一特性又还有所不同，例如：

```js
// 使用eval声明
eval('var b = 300');
// 它的性质是可删除的
Object.getOwnPropertyDescriptor(globalThis, 'b').configurable;
// true
// 检测与删除
b
// 300
delete b
// true
b
// VM1239:1 Uncaught ReferenceError: b is not defined
```

这种情况下使用var声明的变量名尽管也会添加到 varNames 列表，但它也可以从 varNames 中移除（这是唯一一种能从 varNames 中移除项的特例，而 lexicalNames 中的项是不可移除的）。

#### 发生了什么？

所以，现在回到今天讨论的这行代码var x = y = 100，在这行代码中，等号的右边是一个表达式y = 100，它发生了一次“向不存在的变量赋值”，所以它隐式地声明了一个全局变量y，并赋值为 100。

而一个赋值表达式操作本身也是有“结果（Result）”的，它是右操作数的值。注意，这里是“值”而非“引用”，例如下面的测试中的a将是一个函数，而不是带着“this 对象”信息的方法：

```js
// 调用obj.f()时将检测this是不是原始的obj
obj = { 
    f: function() { 
        return this === obj 
    } 
};
// false，表明赋值表达式的“结果(result)”只是右侧操作数的值，即函数f
(a = obj.f)();
// false
```

到现在为止，我们讲述了整个语句的过程，也就是说，由于“y = 100”的结果是 100，所以该值将作为初始值赋值“变量 x”。并且，从语义上来说，这是变量“x”的初始绑定。

之所以强调这一点，是因为相同的分析过程也可以用在 const 声明上，而 const 声明是只有一次绑定的，常量的初始绑定也是通过“执行赋值过程”来实现的。

#### 知识回顾

+ var 等声明语句总是在变量作用域（变量表）或词法作用域中静态地声明一个或多个标识符。
+ 全局变量的管理方式决定了“向一个不存在的变量赋值”所导致的变量泄漏是不可避免的。
+ 动态添加的“var 声明”是可以删除的，这是唯一能操作 varNames 列表的方式（不过它并不存在多少实用意义）。
+ 变量声明在引擎的处理上被分成两个部分：一部分是静态的、基于标识符的词法分析和管理，它总是在相应上下文的环境构建时作为名字创建的；另一部分是表达式执行过程，是对上述名字的赋值，这个过程也称为绑定。
+ 这一讲标题里的这行代码中，x 和 y 是两个不同的东西，前者是声明的名字，后者是一个赋值过程可能创建的变量名。

#### 思考题

根据今天讲解的内容，我希望你可以尝试回答以下问题：

+ 严格来说，声明不是语句。但是，是哪些特性决定了声明不是“严格意义上的”语句呢？

  > 声明和语句的区别在于发生的时间点不同，声明发生在编译期，语句发生在运行期。声明发生在编译期，由编译器为所声明的变量在相应的变量表，增加一个名字。语句是要在运行时执行的程序代码。因此，如果声明不带初始化，那么可以完全由编译器完成，不会产生运行时执行的代码。

在下一讲中我会来讲一讲 JavaScript 社区中的一个历史悬案，这桩悬案与今天讨论的这行代码的唯一区别在于：它不是声明语句，而是赋值表达式。

### 03｜a.x = a = {n:2}：一道被无数人无数次地解释过的经典面试题



